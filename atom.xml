<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[JustBB]]></title>
  <link href="justbb.fun/atom.xml" rel="self"/>
  <link href="justbb.fun/"/>
  <updated>2025-03-22T19:42:18+08:00</updated>
  <id>justbb.fun/</id>
  <author>
    <name><![CDATA[]]></name>
  </author>
  
  <entry>
    <title type="html"><![CDATA[JS：代码执行环境与执行活动栈]]></title>
    <link href="justbb.fun/17426296020776.html"/>
    <updated>2025-03-22T15:46:42+08:00</updated>
    <id>justbb.fun/17426296020776.html</id>
    <content type="html">
<![CDATA[<p>在 JavaScript 中，代码的执行环境和执行活动栈（Execution Context and Call Stack）是理解 JavaScript 运行机制的核心概念。它们决定了代码的执行顺序、作用域、变量访问等行为。</p>
<h3><a id="%E7%A4%BA%E6%84%8F%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示意图</h3>
<pre><code class="language-javascript">//试着画出下面代码的执行逻辑
let a = 123
function abc() {
    let a = 100
    return function (x) {
        a += x
        console.log(a);
    }
}
const c = abc()
c(200) //输出 300
c(600) //输出 900
const d = abc()  
d(666) //输出 766
</code></pre>
<ul>
<li>每次调用 <code>abc()</code> 都会创建一个新的闭包，闭包中的变量 <code>a</code> 是独立的。</li>
<li><code>c</code> 和 <code>d</code> 是两个不同的闭包，它们内部的变量 <code>a</code> 互不影响。</li>
<li>输出结果分别为 <code>300</code>、<code>900</code> 和 <code>766</code>。</li>
</ul>
<p><img src="media/17426296020776/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83.jpg" alt="代码执行环境" /></p>
<h3><a id="1%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%EF%BC%88-execution-context%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. 执行环境（Execution Context）</h3>
<p>执行环境是 JavaScript 代码执行时的抽象概念，它包含了当前代码执行所需的所有信息。每当 JavaScript 引擎执行一段代码时，都会创建一个执行环境。</p>
<h4><a id="%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>执行环境的类型：</h4>
<ol>
<li>
<p><strong>全局执行环境（Global Execution Context）</strong>：</p>
<ul>
<li>
<p>这是最外层的执行环境，对应全局作用域。</p>
</li>
<li>
<p>在浏览器中，全局执行环境的 <code>this</code> 指向 <code>window</code> 对象。</p>
</li>
<li>
<p>全局执行环境在脚本加载时创建，直到页面关闭时销毁。</p>
</li>
</ul>
</li>
<li>
<p><strong>函数执行环境（Function Execution Context）</strong>：</p>
<ul>
<li>
<p>每次调用函数时，都会创建一个新的函数执行环境。</p>
</li>
<li>
<p>函数执行环境包含了函数的局部变量、参数、作用域链等信息。</p>
</li>
<li>
<p>函数执行完成后，其执行环境会被销毁。</p>
</li>
</ul>
</li>
<li>
<p><strong>Eval 执行环境（Eval Execution Context）</strong>：</p>
<ul>
<li>使用 <code>eval</code> 函数时创建的执行环境（不推荐使用 <code>eval</code>，因此很少讨论）。</li>
</ul>
</li>
</ol>
<hr />
<h3><a id="2%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E7%BB%84%E6%88%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. 执行环境的组成</h3>
<p>每个执行环境包含以下三个部分：</p>
<ol>
<li>
<p><strong>变量对象（Variable Object, VO）</strong>：</p>
<ul>
<li>
<p>存储当前环境中定义的变量、函数声明和函数参数。</p>
</li>
<li>
<p>在全局环境中，变量对象是全局对象（如 <code>window</code>）。</p>
</li>
<li>
<p>在函数环境中，变量对象是活动对象（Activation Object, AO）。</p>
</li>
</ul>
</li>
<li>
<p><strong>作用域链（Scope Chain）</strong>：</p>
<ul>
<li>
<p>作用域链是一个链表，用于解析变量和函数。</p>
</li>
<li>
<p>当访问一个变量时，JavaScript 引擎会沿着作用域链从当前环境向上查找，直到找到该变量或到达全局环境。</p>
</li>
</ul>
</li>
<li>
<p><strong><code>this</code> 值</strong>：</p>
<ul>
<li>
<p><code>this</code> 指向当前执行环境的上下文对象。</p>
</li>
<li>
<p>在全局环境中，<code>this</code> 指向全局对象（如 <code>window</code>）。</p>
</li>
<li>
<p>在函数环境中，<code>this</code> 的值取决于函数的调用方式。</p>
</li>
</ul>
</li>
</ol>
<hr />
<h3><a id="3%E6%89%A7%E8%A1%8C%E6%B4%BB%E5%8A%A8%E6%A0%88%EF%BC%88-call-stack%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. 执行活动栈（Call Stack）</h3>
<p>执行活动栈（也称为调用栈）是一个后进先出（LIFO）的栈结构，用于管理执行环境的创建和销毁。</p>
<h4><a id="%E6%89%A7%E8%A1%8C%E6%B4%BB%E5%8A%A8%E6%A0%88%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>执行活动栈的工作流程：</h4>
<ol>
<li>
<p><strong>初始状态</strong>：</p>
<ul>
<li>当 JavaScript 脚本开始执行时，全局执行环境被创建并推入调用栈。</li>
</ul>
</li>
<li>
<p><strong>函数调用</strong>：</p>
<ul>
<li>
<p>当调用一个函数时，会创建一个新的函数执行环境，并将其推入调用栈。</p>
</li>
<li>
<p>函数执行完成后，其执行环境从调用栈中弹出。</p>
</li>
</ul>
</li>
<li>
<p><strong>栈溢出</strong>：</p>
<ul>
<li>如果递归调用过深或函数调用过多，调用栈可能会超出其最大限制，导致栈溢出错误（Stack Overflow）。</li>
</ul>
</li>
</ol>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">function first() {
    console.log(&quot;First&quot;);
    second();
}

function second() {
    console.log(&quot;Second&quot;);
    third();
}

function third() {
    console.log(&quot;Third&quot;);
}

first();

</code></pre>
<h4><a id="%E8%B0%83%E7%94%A8%E6%A0%88%E7%9A%84%E5%8F%98%E5%8C%96%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调用栈的变化：</h4>
<ol>
<li>
<p>全局执行环境被推入调用栈。</p>
</li>
<li>
<p>调用 <code>first()</code>，<code>first</code> 的执行环境被推入调用栈。</p>
</li>
<li>
<p>在 <code>first</code> 中调用 <code>second()</code>，<code>second</code> 的执行环境被推入调用栈。</p>
</li>
<li>
<p>在 <code>second</code> 中调用 <code>third()</code>，<code>third</code> 的执行环境被推入调用栈。</p>
</li>
<li>
<p><code>third</code> 执行完成后，其执行环境从调用栈中弹出。</p>
</li>
<li>
<p><code>second</code> 执行完成后，其执行环境从调用栈中弹出。</p>
</li>
<li>
<p><code>first</code> 执行完成后，其执行环境从调用栈中弹出。</p>
</li>
<li>
<p>最后，全局执行环境从调用栈中弹出（脚本执行完毕）。</p>
</li>
</ol>
<hr />
<h3><a id="4%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E7%9A%84%E5%85%B3%E7%B3%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. 执行环境和作用域链的关系</h3>
<p>作用域链是执行环境的一个重要组成部分，它决定了变量的可访问性。</p>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">const globalVar = &quot;Global&quot;;

function outer() {
    const outerVar = &quot;Outer&quot;;

    function inner() {
        const innerVar = &quot;Inner&quot;;
        console.log(globalVar); // 输出: Global
        console.log(outerVar); // 输出: Outer
        console.log(innerVar); // 输出: Inner
    }

    inner();
}

outer();
</code></pre>
<h4><a id="%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>作用域链：</h4>
<ul>
<li>
<p><code>inner</code> 函数的作用域链：<code>inner</code> → <code>outer</code> → 全局。</p>
</li>
<li>
<p>当 <code>inner</code> 访问 <code>globalVar</code> 时，JavaScript 引擎会沿着作用域链向上查找，直到找到 <code>globalVar</code>。</p>
</li>
</ul>
<hr />
<h3><a id="5%E9%97%AD%E5%8C%85%E4%B8%8E%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5. 闭包与执行环境</h3>
<p>闭包是函数与其词法作用域的结合。即使函数在其词法作用域外执行，它仍然可以访问其词法作用域中的变量。</p>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">function outer() {
    const outerVar = &quot;Outer&quot;;

    function inner() {
        console.log(outerVar); // 输出: Outer
    }

    return inner;
}

const closure = outer();
closure();

</code></pre>
<h4><a id="%E8%A7%A3%E9%87%8A%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>解释：</h4>
<ul>
<li>
<p><code>inner</code> 函数形成了一个闭包，它“记住”了 <code>outer</code> 函数的词法作用域。</p>
</li>
<li>
<p>即使 <code>outer</code> 函数已经执行完毕，<code>inner</code> 仍然可以访问 <code>outerVar</code>。</p>
</li>
</ul>
<hr />
<h3><a id="%E6%80%BB%E7%BB%93%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结：</h3>
<ul>
<li>
<p><strong>执行环境</strong>：是 JavaScript 代码执行时的抽象概念，包含变量对象、作用域链和 <code>this</code> 值。</p>
</li>
<li>
<p><strong>执行活动栈</strong>：是一个后进先出的栈结构，用于管理执行环境的创建和销毁。</p>
</li>
<li>
<p><strong>作用域链</strong>：决定了变量的可访问性，沿着作用域链从当前环境向上查找变量。</p>
</li>
<li>
<p><strong>闭包</strong>：是函数与其词法作用域的结合，即使函数在其词法作用域外执行，仍然可以访问其词法作用域中的变量。</p>
</li>
</ul>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网页内容抓取工具 bowser flow]]></title>
    <link href="justbb.fun/17425245814203.html"/>
    <updated>2025-03-21T10:36:21+08:00</updated>
    <id>justbb.fun/17425245814203.html</id>
    <content type="html">
<![CDATA[<p>推荐一个自动化抓取工具的浏览器插件，我最近为了研究公司的客户数据，用这个插件帮了大忙。</p>
<p>原本可能要一天才能统计完的数据，几分钟就搞定了。</p>
<p><a href="https://browserflow.app/">Browserflow</a></p>
<p><video src = 'https://browserflow.app/videos/bf-demo.mp4#t=0.1'></video></p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[推荐一个PDF文档翻译工具]]></title>
    <link href="justbb.fun/17425235826405.html"/>
    <updated>2025-03-21T10:19:42+08:00</updated>
    <id>justbb.fun/17425235826405.html</id>
    <content type="html">
<![CDATA[<p><a href="https://github.com/Byaidu/PDFMathTranslate?tab=readme-ov-file">https://github.com/Byaidu/PDFMathTranslate?tab=readme-ov-file</a></p>
<p>PDF科学论文翻译及双语比较。</p>
<ol>
<li>📊 保存公式、图表、目录和注释（预览）。</li>
<li>🌐支持多种语言，多样化的翻译服务。</li>
<li>🤖 提供命令行工具、交互式用户界面和Docker</li>
</ol>
<p>翻译能保留原格式。</p>
<p><img src="media/17425235826405/123.jpg" alt="img" /></p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JS：闭包]]></title>
    <link href="justbb.fun/17423901549383.html"/>
    <updated>2025-03-19T21:15:54+08:00</updated>
    <id>justbb.fun/17423901549383.html</id>
    <content type="html">
<![CDATA[<p><strong>闭包（Closure）</strong> 是 JavaScript 中一个非常重要的概念，它允许函数访问其词法作用域中的变量，即使函数在其词法作用域之外执行。闭包的原理和意义在 JavaScript 开发中非常关键，以下是详细说明：</p>
<hr />
<h3><a id="1%E9%97%AD%E5%8C%85%E7%9A%84%E5%8E%9F%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>1. 闭包的原理</strong></h3>
<h4><a id="1%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(1) 词法作用域</strong></h4>
<ul>
<li>
<p>JavaScript 使用<strong>词法作用域</strong>（Lexical Scope），即函数的作用域在函数定义时就已经确定，而不是在函数调用时确定。</p>
</li>
<li>
<p>函数可以访问其定义时所处的作用域中的变量。</p>
</li>
</ul>
<h4><a id="2%E9%97%AD%E5%8C%85%E7%9A%84%E5%BD%A2%E6%88%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(2) 闭包的形成</strong></h4>
<ul>
<li>
<p>当一个函数在其词法作用域之外执行时，仍然可以访问其词法作用域中的变量，这时就形成了闭包。</p>
</li>
<li>
<p>闭包的本质是函数与其词法作用域的结合。</p>
</li>
</ul>
<h4><a id="3%E9%97%AD%E5%8C%85%E5%BD%A2%E6%88%90%E7%9A%84%E6%9D%A1%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(3) 闭包形成的条件</strong></h4>
<p>闭包的形成需要满足以下条件：</p>
<ol>
<li><strong>函数嵌套：</strong> 闭包通常发生在函数内部定义了另一个函数（即嵌套函数）。外层函数提供了一个作用域环境，内层函数可以访问这个环境。</li>
<li><strong>内部函数引用外部变量：</strong> 内层函数必须引用外层函数作用域中的变量或参数。如果内层函数没有引用外层作用域的变量，就不会形成闭包。</li>
<li><strong>外部函数返回内部函数：</strong> 外层函数需要将其内部函数返回，或者以某种方式将内部函数暴露出去（比如赋值给外部变量）。这样，内部函数可以在外部函数执行完毕后仍然被调用。</li>
<li><strong>外部函数被调用且执行完成：</strong> 闭包的形成是在外层函数执行完毕后，内部函数依然能够“记住”外层函数作用域中的变量。这是由于 JavaScript 的作用域链和垃圾回收机制，外部变量不会被销毁，因为内部函数仍然持有对它们的引用。</li>
</ol>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>示例：</strong></h4>
<pre><code class="language-javascript">function outer() {
    let count = 0; // 外层函数的变量
    function inner() { // 内层函数
        count++; // 引用外层变量
        console.log(count);
    }
    return inner; // 返回内层函数
}

const fn = outer(); // outer 执行并返回 inner
fn(); // 输出 1
fn(); // 输出 2
</code></pre>
<p>在这个例子中：</p>
<ul>
<li>
<p><code>inner</code> 函数引用了 <code>outer</code> 的变量 <code>count</code>。</p>
</li>
<li>
<p><code>outer</code> 返回了 <code>inner</code>，使得 <code>inner</code> 可以在外部被调用。</p>
</li>
<li>
<p>即使 <code>outer</code> 执行完毕，<code>count</code> 依然被 <code>inner</code> “记住”，形成了闭包。</p>
</li>
</ul>
<hr />
<h3><a id="2%E9%97%AD%E5%8C%85%E7%9A%84%E6%84%8F%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>2. 闭包的意义</strong></h3>
<h4><a id="1%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(1) 数据封装</strong></h4>
<ul>
<li>
<p>闭包可以用于创建私有变量和方法，从而实现数据封装。</p>
</li>
<li>
<p>私有变量只能在闭包内部访问，外部无法直接修改或访问。</p>
</li>
</ul>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">function createCounter() {
  let count = 0; // 私有变量

  return {
    increment() {
      count++;
    },
    getCount() {
      return count;
    }
  };
}

const counter = createCounter();
counter.increment();
console.log(counter.getCount()); // 输出: 1
</code></pre>
<ul>
<li>在上面的例子中，<code>count</code> 是一个私有变量，只能通过 <code>increment</code> 和 <code>getCount</code> 方法访问和修改。</li>
</ul>
<hr />
<h4><a id="2%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(2) 回调函数</strong></h4>
<ul>
<li>闭包常用于回调函数中，确保回调函数可以访问定义时的上下文。</li>
</ul>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">function fetchData(callback) {
  setTimeout(() =&gt; {
    const data = &quot;Some data&quot;;
    callback(data);
  }, 1000);
}

function processData() {
  const prefix = &quot;Processed: &quot;;

  fetchData(function (data) {
    console.log(prefix + data); // 访问外部函数的变量
  });
}

processData(); // 输出: Processed: Some data

</code></pre>
<ul>
<li>在上面的例子中，回调函数可以访问 <code>processData</code> 函数中的 <code>prefix</code> 变量。</li>
</ul>
<hr />
<h4><a id="3%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(3) 函数柯里化</strong></h4>
<ul>
<li>闭包可以用于实现函数柯里化（Currying），即将一个多参数函数转换为一系列单参数函数。</li>
</ul>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">function add(a) {
  return function (b) {
    return a + b;
  };
}

const add5 = add(5); // 返回一个函数，a 被固定为 5
console.log(add5(10)); // 输出: 15

</code></pre>
<ul>
<li>在上面的例子中，<code>add5</code> 是一个闭包，它记住了 <code>a</code> 的值（5）。</li>
</ul>
<hr />
<h4><a id="4%E6%A8%A1%E5%9D%97%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(4) 模块模式</strong></h4>
<ul>
<li>闭包可以用于实现模块模式，将相关的变量和函数封装在一个作用域中，避免污染全局作用域。</li>
</ul>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">const module = (function () {
  const privateVar = &quot;I am private&quot;;

  function privateMethod() {
    console.log(privateVar);
  }

  return {
    publicMethod() {
      privateMethod();
    }
  };
})();

module.publicMethod(); // 输出: I am private
</code></pre>
<ul>
<li>在上面的例子中，<code>privateVar</code> 和 <code>privateMethod</code> 是私有的，只能通过 <code>publicMethod</code> 访问。</li>
</ul>
<hr />
<h3><a id="3%E9%97%AD%E5%8C%85%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>3. 闭包的注意事项</strong></h3>
<h4><a id="1%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(1) 内存泄漏</strong></h4>
<ul>
<li>
<p>闭包会导致外部函数的变量无法被垃圾回收，从而可能导致内存泄漏。</p>
</li>
<li>
<p>如果不再需要闭包，应该手动解除引用。</p>
</li>
</ul>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">function createHeavyClosure() {
  const largeArray = new Array(1000000).fill(&quot;data&quot;);

  return function () {
    console.log(largeArray[0]);
  };
}

let heavyFunc = createHeavyClosure();
heavyFunc(); // 使用闭包

// 不再需要时，解除引用
heavyFunc = null;

</code></pre>
<hr />
<h4><a id="2%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(2) 性能问题</strong></h4>
<ul>
<li>
<p>闭包会增加作用域链的长度，从而可能影响性能。</p>
</li>
<li>
<p>在性能敏感的场景中，应谨慎使用闭包。</p>
</li>
</ul>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JS：解构赋值]]></title>
    <link href="justbb.fun/17422636944234.html"/>
    <updated>2025-03-18T10:08:14+08:00</updated>
    <id>justbb.fun/17422636944234.html</id>
    <content type="html">
<![CDATA[<p><strong>解构赋值</strong>（Destructuring Assignment）是 JavaScript 中的一种语法，用于从数组或对象中提取值，并将其赋值给变量。解构赋值可以使代码更简洁、更易读。以下是关于解构赋值的详细说明和示例：</p>
<hr />
<h3><a id="1%E6%95%B0%E7%BB%84%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>1. 数组的解构赋值</strong></h3>
<h4><a id="1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(1) 基本用法</strong></h4>
<p>从数组中提取值，并赋值给变量。</p>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">const arr = [1, 2, 3];

// 传统写法
const a = arr[0];
const b = arr[1];
const c = arr[2];

// 解构赋值
const [x, y, z] = arr;

console.log(x, y, z); // 输出: 1 2 3
</code></pre>
<hr />
<h4><a id="2%E5%BF%BD%E7%95%A5%E6%9F%90%E4%BA%9B%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(2) 忽略某些值</strong></h4>
<p>可以使用逗号跳过不需要的值。</p>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">const arr = [1, 2, 3];

const [a, , c] = arr;

console.log(a, c); // 输出: 1 3

</code></pre>
<hr />
<h4><a id="3%E9%BB%98%E8%AE%A4%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(3) 默认值</strong></h4>
<p>如果解构的值是 <code>undefined</code>，可以使用默认值。示例为变量设定了默认值<code>(10，20)</code>。当数组中的元素数量少于变量数量时，未匹配到元素的变量会使用默认值。</p>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">const arr = [1];

const [a = 10, b = 20] = arr;

console.log(a, b); // 输出: 1 20

</code></pre>
<p><code>a = 10</code>：若 <code>arr</code> 数组里有第一个元素，就将其赋值给 <code>a</code>；要是没有，<code>a</code> 就会使用默认值 <code>10</code>。<br />
<code>b = 20</code>：若 <code>arr</code> 数组里有第二个元素，就把它赋值给 <code>b</code>；若没有，<code>b</code> 就使用默认值 <code>20</code>。<br />
由于 <code>arr</code> 数组中仅有一个元素 <code>1</code>，所以 <code>a</code> 被赋值为 <code>1</code>；而数组中不存在第二个元素，因此 <code>b</code> 使用默认值 <code>20</code>。最终输出的结果是 <code>1</code> <code>20</code>。</p>
<hr />
<h4><a id="4%E5%89%A9%E4%BD%99%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(4) 剩余值</strong></h4>
<p>使用 <code>...</code> 将剩余的值赋值给一个变量。</p>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">const arr = [1, 2, 3, 4];

const [a, b, ...rest] = arr;

console.log(a, b, rest); // 输出: 1 2 [3, 4]

</code></pre>
<hr />
<h3><a id="2%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>2. 对象的解构赋值</strong></h3>
<h4><a id="1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(1) 基本用法</strong></h4>
<p>从对象中提取值，并赋值给变量。</p>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">const person = {
  name: &quot;Alice&quot;,
  age: 25
};

// 传统写法
const name = person.name;
const age = person.age;

// 解构赋值
const { name, age } = person;

console.log(name, age); // 输出: Alice 25
</code></pre>
<hr />
<h4><a id="2%E9%87%8D%E5%91%BD%E5%90%8D%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(2) 重命名变量</strong></h4>
<p>可以使用 <code>:</code> 将属性值赋值给不同名称的变量。</p>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">const person = {
  name: &quot;Alice&quot;,
  age: 25
};

const { name: fullName, age: years } = person;

console.log(fullName, years); // 输出: Alice 25
</code></pre>
<hr />
<h4><a id="3%E9%BB%98%E8%AE%A4%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(3) 默认值</strong></h4>
<p>如果解构的值是 <code>undefined</code>，可以使用默认值。</p>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">const person = {
  name: &quot;Alice&quot;
};

const { name, age = 20 } = person;

console.log(name, age); // 输出: Alice 20
</code></pre>
<hr />
<h4><a id="4%E5%B5%8C%E5%A5%97%E8%A7%A3%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(4) 嵌套解构</strong></h4>
<p>可以解构嵌套的对象。</p>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">const person = {
  name: &quot;Alice&quot;,
  age: 25,
  address: {
    city: &quot;Beijing&quot;,
    country: &quot;China&quot;
  }
};

const { name, address: { city } } = person;

console.log(name, city); // 输出: Alice Beijing

</code></pre>
<hr />
<h4><a id="5%E5%89%A9%E4%BD%99%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(5) 剩余值</strong></h4>
<p>使用 <code>...</code> 将剩余的属性赋值给一个变量。</p>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">const person = {
  name: &quot;Alice&quot;,
  age: 25,
  city: &quot;Beijing&quot;
};

const { name, ...rest } = person;

console.log(name, rest); // 输出: Alice { age: 25, city: 'Beijing' }
</code></pre>
<hr />
<h3><a id="3%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%AD%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>3. 函数参数中的解构赋值</strong></h3>
<h4><a id="1%E5%AF%B9%E8%B1%A1%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(1) 对象参数</strong></h4>
<p>在函数参数中使用解构赋值，可以直接提取对象中的属性。</p>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">function greet({ name, age }) {
  console.log(`Hello, ``{name}. You are ``{age} years old.`);
}

const person = {
  name: &quot;Alice&quot;,
  age: 25
};

greet(person); // 输出: Hello, Alice. You are 25 years old.
</code></pre>
<hr />
<h4><a id="2%E6%95%B0%E7%BB%84%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(2) 数组参数</strong></h4>
<p>在函数参数中使用解构赋值，可以直接提取数组中的值。</p>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">function sum([a, b]) {
  return a + b;
}

const arr = [1, 2];

console.log(sum(arr)); // 输出: 3

</code></pre>
<hr />
<h3><a id="4%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>4. 解构赋值的注意事项</strong></h3>
<h4><a id="1%E8%A7%A3%E6%9E%84%E5%A4%B1%E8%B4%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(1) 解构失败</strong></h4>
<p>如果解构的值是 <code>undefined</code> 或 <code>null</code>，解构会失败并抛出错误。</p>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">const { a } = undefined; // 报错: Cannot destructure property 'a' of 'undefined'
</code></pre>
<hr />
<h4><a id="2%E9%BB%98%E8%AE%A4%E5%80%BC%E4%B8%8E%E9%87%8D%E5%91%BD%E5%90%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(2) 默认值与重命名</strong></h4>
<p>可以同时使用默认值和重命名。</p>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">const person = {
  name: &quot;Alice&quot;
};

const { name: fullName = &quot;Unknown&quot;, age = 20 } = person;

console.log(fullName, age); // 输出: Alice 20
</code></pre>
<hr />
<h3><a id="5%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>5. 总结</strong></h3>
<ul>
<li>
<p>解构赋值是一种从数组或对象中提取值的语法。</p>
</li>
<li>
<p>数组解构赋值使用 <code>[]</code>，对象解构赋值使用 <code>{}</code>。</p>
</li>
<li>
<p>解构赋值支持默认值、重命名、嵌套解构和剩余值。</p>
</li>
<li>
<p>解构赋值可以使代码更简洁、更易读。</p>
</li>
</ul>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JS：包装类]]></title>
    <link href="justbb.fun/17422152083924.html"/>
    <updated>2025-03-17T20:40:08+08:00</updated>
    <id>justbb.fun/17422152083924.html</id>
    <content type="html">
<![CDATA[<p>在 JavaScript 中，<strong>包装类（Wrapper Objects）</strong> 是一种特殊的对象类型，用于将原始值（如字符串、数字、布尔值）临时转换为对象，以便可以调用对象的方法。JavaScript 提供了三种主要的包装类：</p>
<ol>
<li>
<p><strong><code>String</code></strong>：用于包装字符串原始值。</p>
</li>
<li>
<p><strong><code>Number</code></strong>：用于包装数字原始值。</p>
</li>
<li>
<p><strong><code>Boolean</code></strong>：用于包装布尔原始值。</p>
</li>
</ol>
<hr />
<h3><a id="1%C2%A0%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. <strong>包装类的作用</strong></h3>
<p>原始值（如 <code>&quot;hello&quot;</code>、<code>42</code>、<code>true</code>）本身不是对象，因此不能直接调用方法。包装类的作用是临时将原始值转换为对象，以便可以调用对象的方法。</p>
<p>例如：</p>
<pre><code class="language-javascript">const str = &quot;hello&quot;;
console.log(str.toUpperCase()); // &quot;HELLO&quot;

</code></pre>
<p>在上面的代码中：</p>
<ul>
<li>
<p><code>str</code> 是一个字符串原始值。</p>
</li>
<li>
<p>当调用 <code>toUpperCase()</code> 方法时，JavaScript 会临时将 <code>str</code> 转换为一个 <code>String</code> 对象，然后调用方法。</p>
</li>
<li>
<p>方法调用结束后，临时对象会被丢弃。</p>
</li>
</ul>
<hr />
<h3><a id="2%C2%A0%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. <strong>包装类的创建</strong></h3>
<p>你可以显式地使用包装类来创建对象：</p>
<pre><code class="language-javascript">const strObj = new String(&quot;hello&quot;); // String 对象
const numObj = new Number(42);      // Number 对象
const boolObj = new Boolean(true); // Boolean 对象

</code></pre>
<p>这些对象的行为与原始值类似，但它们是对象类型（<code>object</code>），而不是原始类型（<code>string</code>、<code>number</code>、<code>boolean</code>）。</p>
<hr />
<h3><a id="3%C2%A0%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B8%8E%E5%8E%9F%E5%A7%8B%E5%80%BC%E7%9A%84%E5%8C%BA%E5%88%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. <strong>包装类与原始值的区别</strong></h3>
<p>包装类是对象，而原始值不是对象。它们的区别主要体现在类型和行为上：</p>
<h4><a id="%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类型</h4>
<pre><code class="language-javascript">const str = &quot;hello&quot;;
const strObj = new String(&quot;hello&quot;);

console.log(typeof str);    // &quot;string&quot;
console.log(typeof strObj); // &quot;object&quot;

</code></pre>
<h4><a id="%E8%A1%8C%E4%B8%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>行为</h4>
<pre><code class="language-javascript">const str1 = &quot;hello&quot;;
const str2 = new String(&quot;hello&quot;);

console.log(str1 === &quot;hello&quot;); // true
console.log(str2 === &quot;hello&quot;); // false
</code></pre>
<ul>
<li>
<p><code>str1</code> 是原始值，直接与 <code>&quot;hello&quot;</code> 比较时，值相等。</p>
</li>
<li>
<p><code>str2</code> 是对象，与 <code>&quot;hello&quot;</code> 比较时，类型不同，结果为 <code>false</code>。</p>
</li>
</ul>
<hr />
<h3><a id="4%C2%A0%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. <strong>包装类的使用场景</strong></h3>
<p>包装类的主要用途是提供对原始值的方法调用支持。例如：</p>
<h4><a id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>字符串方法</h4>
<pre><code class="language-javascript">const str = &quot;hello&quot;;
console.log(str.length); // 5
console.log(str.toUpperCase()); // &quot;HELLO&quot;

</code></pre>
<h4><a id="%E6%95%B0%E5%AD%97%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数字方法</h4>
<pre><code class="language-javascript">const num = 42.567;
console.log(num.toFixed(2)); // &quot;42.57&quot;
</code></pre>
<h4><a id="%E5%B8%83%E5%B0%94%E5%80%BC%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>布尔值方法</h4>
<pre><code class="language-javascript">const bool = true;
console.log(bool.toString()); // &quot;true&quot;

</code></pre>
<p>在这些例子中，JavaScript 会临时将原始值转换为包装类对象，以便调用方法。</p>
<hr />
<h3><a id="5%C2%A0%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5. <strong>注意事项</strong></h3>
<h4><a id="1%E4%B8%8D%E8%A6%81%E6%98%BE%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%8C%85%E8%A3%85%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. 不要显式使用包装类</h4>
<p>通常情况下，不需要显式使用包装类（如 <code>new String(&quot;hello&quot;)</code>），因为 JavaScript 会自动处理原始值的方法调用。</p>
<h4><a id="2%E5%8C%85%E8%A3%85%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AF%94%E8%BE%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. 包装类对象的比较</h4>
<p>包装类对象是对象，因此它们的比较是基于引用的，而不是值：</p>
<pre><code class="language-javascript">const str1 = new String(&quot;hello&quot;);
const str2 = new String(&quot;hello&quot;);

console.log(str1 === str2); // false
console.log(str1 == str2);  // false

</code></pre>
<h4><a id="3%E5%8E%9F%E5%A7%8B%E5%80%BC%E7%9A%84%E6%80%A7%E8%83%BD%E6%9B%B4%E5%A5%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. 原始值的性能更好</h4>
<p>原始值的性能比包装类对象更好，因为包装类对象需要额外的内存和计算资源。</p>
<hr />
<h3><a id="6%C2%A0%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>6. <strong>包装类的原型链</strong></h3>
<p>包装类的实例会继承对应包装类原型上的方法。例如：</p>
<pre><code class="language-javascript">const str = &quot;hello&quot;;
console.log(str.__proto__ === String.prototype); // true
</code></pre>
<ul>
<li>
<p><code>String.prototype</code> 是 <code>String</code> 包装类的原型对象。</p>
</li>
<li>
<p><code>str</code> 是一个字符串原始值，但它可以访问 <code>String.prototype</code> 上的方法（如 <code>toUpperCase</code>、<code>slice</code>等）。</p>
</li>
</ul>
<hr />
<h3><a id="7%C2%A0%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>7. <strong>总结</strong></h3>
<ul>
<li>
<p>包装类（<code>String</code>、<code>Number</code>、<code>Boolean</code>）用于将原始值临时转换为对象，以便调用方法。</p>
</li>
<li>
<p>通常情况下，不需要显式使用包装类，JavaScript 会自动处理原始值的方法调用。</p>
</li>
<li>
<p>包装类对象是对象类型，与原始值有本质区别。</p>
</li>
<li>
<p>原始值的性能更好，建议优先使用原始值。</p>
</li>
</ul>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JS：类 class]]></title>
    <link href="justbb.fun/17421328791971.html"/>
    <updated>2025-03-16T21:47:59+08:00</updated>
    <id>justbb.fun/17421328791971.html</id>
    <content type="html">
<![CDATA[<p>在 JavaScript 中，<code>class</code> 是用于定义类（Class）的关键字。类是面向对象编程（OOP）的核心概念，它提供了一种更清晰、更结构化的方式来创建对象和管理继承关系。以下是关于 <code>class</code> 的详细说明：</p>
<hr />
<h3><a id="1%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>1. 类的基本语法</strong></h3>
<p>使用 <code>class</code> 关键字可以定义一个类。类通常包含构造函数、实例方法、静态方法和静态属性。</p>
<h4><a id="%E8%AF%AD%E6%B3%95%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>语法：</h4>
<pre><code class="language-javascript">class ClassName {
  constructor(/* 参数 */) {
    // 初始化属性
  }

  // 实例方法
  methodName() {
    // 方法逻辑
  }

  // 静态方法
  static staticMethodName() {
    // 静态方法逻辑
  }

  // 静态属性
  static staticPropertyName = value;
}

</code></pre>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  // 实例方法
  greet() {
    console.log(`Hello, my name is ${this.name}`);
  }

  // 静态方法
  static info() {
    console.log(&quot;This is a Person class.&quot;);
  }

  // 静态属性
  static species = &quot;Human&quot;;
}

const person = new Person(&quot;Alice&quot;, 25);
person.greet(); // 输出: Hello, my name is Alice
Person.info();  // 输出: This is a Person class.
console.log(Person.species); // 输出: Human
</code></pre>
<hr />
<h3><a id="2%E7%B1%BB%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>2. 类的组成部分</strong></h3>
<h4><a id="1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-constructor%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(1) 构造函数 (<code>constructor</code>)</strong>：</h4>
<ul>
<li>
<p>构造函数用于初始化对象的属性。</p>
</li>
<li>
<p>当使用 <code>new</code> 关键字创建类的实例时，构造函数会被自动调用。</p>
</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">class Person {
  constructor(name) {
    this.name = name;
  }
}

const person = new Person(&quot;Alice&quot;);
console.log(person.name); // 输出: Alice
</code></pre>
<hr />
<h4><a id="2%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(2) 实例方法</strong>：</h4>
<ul>
<li>
<p>实例方法是类的原型方法，可以被类的实例调用。</p>
</li>
<li>
<p>实例方法可以访问实例的属性（通过 <code>this</code>）。</p>
</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">class Person {
  constructor(name) {
    this.name = name;
  }

  greet() {
    console.log(`Hello, my name is ${this.name}`);
  }
}

const person = new Person(&quot;Alice&quot;);
person.greet(); // 输出: Hello, my name is Alice
</code></pre>
<hr />
<h4><a id="3%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-static%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(3) 静态方法 (<code>static</code>)</strong>：</h4>
<ul>
<li>
<p>静态方法属于类本身，而不是类的实例。</p>
</li>
<li>
<p>静态方法通过类名调用，而不是实例。</p>
</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">class Person {
  static info() {
    console.log(&quot;This is a Person class.&quot;);
  }
}

Person.info(); // 输出: This is a Person class.

</code></pre>
<hr />
<h4><a id="4%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7-static%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(4) 静态属性 (<code>static</code>)</strong>：</h4>
<ul>
<li>
<p>静态属性属于类本身，而不是类的实例。</p>
</li>
<li>
<p>静态属性通过类名访问。</p>
</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">class Person {
  static species = &quot;Human&quot;;
}

console.log(Person.species); // 输出: Human

</code></pre>
<hr />
<h3><a id="3%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF-extends%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>3. 类的继承 (<code>extends</code>)</strong>：</h3>
<ul>
<li>
<p>使用 <code>extends</code> 关键字可以实现类的继承。</p>
</li>
<li>
<p>子类会继承父类的属性和方法，同时可以定义自己的属性和方法。</p>
</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">class Animal {
  constructor(name) {
    this.name = name;
  }

  speak() {
    console.log(`${this.name} makes a noise.`);
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name); // 调用父类的构造函数
    this.breed = breed;
  }

  bark() {
    console.log(`${this.name} barks!`);
  }
}

const dog = new Dog(&quot;Buddy&quot;, &quot;Golden Retriever&quot;);
dog.speak(); // 输出: Buddy makes a noise.
dog.bark();  // 输出: Buddy barks!
</code></pre>
<hr />
<h3><a id="4%E7%B1%BB%E7%9A%84%E7%89%B9%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>4. 类的特性</strong></h3>
<h4><a id="1%E6%B2%A1%E6%9C%89%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(1) 没有变量提升</strong>：</h4>
<ul>
<li>类声明不会被提升，必须在定义后才能使用。</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">const person = new Person(&quot;Alice&quot;); // 报错: Person is not defined

class Person {
  constructor(name) {
    this.name = name;
  }

}
</code></pre>
<hr />
<h4><a id="2%E5%8F%97%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%99%90%E5%88%B6%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(2) 受块级作用域限制</strong>：</h4>
<ul>
<li>类声明受块级作用域的限制。</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">{
  class Person {
    constructor(name) {
      this.name = name;
    }
  }

  const person = new Person(&quot;Alice&quot;);
  console.log(person.name); // 输出: Alice
}

const person = new Person(&quot;Alice&quot;); // 报错: Person is not defined
</code></pre>
<hr />
<h4><a id="3%E6%96%B9%E6%B3%95%E4%B9%8B%E9%97%B4%E4%B8%8D%E9%9C%80%E8%A6%81%E9%80%97%E5%8F%B7%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(3) 方法之间不需要逗号</strong>：</h4>
<ul>
<li>类中的方法之间不需要逗号分隔。</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">class Person {
  constructor(name) {
    this.name = name;
  }

  greet() {
    console.log(`Hello, ${this.name}`);
  }

  sleep() {
    console.log(`${this.name} is sleeping.`);
  }
}

</code></pre>
<hr />
<h3><a id="5%E7%B1%BB%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>5. 类的实际应用</strong></h3>
<ul>
<li>
<p><strong>封装</strong>：将数据和操作数据的方法封装在一个类中。</p>
</li>
<li>
<p><strong>继承</strong>：通过继承实现代码复用。</p>
</li>
<li>
<p><strong>多态</strong>：子类可以重写父类的方法，实现不同的行为。</p>
</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">class Shape {
  constructor(color) {
    this.color = color;
  }

  draw() {
    console.log(`Drawing a ${this.color} shape.`);
  }
}

class Circle extends Shape {
  constructor(color, radius) {
    super(color);
    this.radius = radius;
  }

  draw() {
    console.log(`Drawing a ``{this.color} circle with radius ``{this.radius}.`);
  }
}

const circle = new Circle(&quot;red&quot;, 10);
circle.draw(); // 输出: Drawing a red circle with radius 10.

</code></pre>
<hr />
<h3><a id="6%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>6. 总结</strong></h3>
<ul>
<li>
<p><code>class</code> 是 JavaScript 中定义类的关键字。</p>
</li>
<li>
<p>类包含构造函数、实例方法、静态方法和静态属性。</p>
</li>
<li>
<p>通过 <code>extends</code> 实现继承。</p>
</li>
<li>
<p>类提供了更清晰、更结构化的方式来创建对象和管理继承关系。</p>
</li>
</ul>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JS：Object上的常用方法]]></title>
    <link href="justbb.fun/17422155623223.html"/>
    <updated>2025-03-17T20:46:02+08:00</updated>
    <id>justbb.fun/17422155623223.html</id>
    <content type="html">
<![CDATA[<p>在 JavaScript 中，<code>Object</code> 是一个内置的构造函数，提供了许多实用的静态方法和实例方法，用于操作对象。以下是 <code>Object</code> 上常用方法的详细说明：</p>
<hr />
<h3><a id="1%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>1. 静态方法</strong></h3>
<h4><a id="1%C2%A0-object-assign-target-sources" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(1) <code>Object.assign(target, ...sources)</code></strong></h4>
<ul>
<li>
<p><strong>作用</strong>：将一个或多个源对象的属性 到目标对象。</p>
</li>
<li>
<p><strong>返回值</strong>：目标对象。</p>
</li>
<li>
<p><strong>注意</strong>：浅拷贝，只 可枚举的自有属性。</p>
</li>
</ul>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">const target = { a: 1 };
const source = { b: 2, c: 3 };

const result = Object.assign(target, source);
console.log(result); // 输出: { a: 1, b: 2, c: 3 }

</code></pre>
<hr />
<h4><a id="2%C2%A0-object-create-proto-propertiesobject" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(2) <code>Object.create(proto, propertiesObject)</code></strong></h4>
<ul>
<li>
<p><strong>作用</strong>：创建一个新对象，使用现有对象作为新对象的原型。</p>
</li>
<li>
<p><strong>参数</strong>：</p>
<ul>
<li>
<p><code>proto</code>：新对象的原型。</p>
</li>
<li>
<p><code>propertiesObject</code>（可选）：新对象的属性描述符。</p>
</li>
</ul>
</li>
</ul>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">const proto = { greet() { console.log(&quot;Hello!&quot;); } };
const obj = Object.create(proto);

obj.greet(); // 输出: Hello!
</code></pre>
<hr />
<h4><a id="3%C2%A0-object-defineproperty-obj-prop-descriptor" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(3) <code>Object.defineProperty(obj, prop, descriptor)</code></strong></h4>
<ul>
<li>
<p><strong>作用</strong>：在对象上定义一个新属性，或修改现有属性。</p>
</li>
<li>
<p><strong>参数</strong>：</p>
<ul>
<li>
<p><code>obj</code>：目标对象。</p>
</li>
<li>
<p><code>prop</code>：属性名称。</p>
</li>
<li>
<p><code>descriptor</code>：属性描述符（如 <code>value</code>、<code>writable</code>、<code>enumerable</code>、<code>configurable</code>）。</p>
</li>
</ul>
</li>
</ul>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">const obj = {};

Object.defineProperty(obj, &quot;name&quot;, {
  value: &quot;Alice&quot;,
  writable: false, // 不可修改
  enumerable: true // 可枚举
});

console.log(obj.name); // 输出: Alice
obj.name = &quot;Bob&quot;; // 无效，因为 writable 为 false
console.log(obj.name); // 输出: Alice

</code></pre>
<hr />
<h4><a id="4%C2%A0-object-entries-obj" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(4) <code>Object.entries(obj)</code></strong></h4>
<ul>
<li>
<p><strong>作用</strong>：返回一个对象自身可枚举属性的键值对数组。</p>
</li>
<li>
<p><strong>返回值</strong>：二维数组，每个元素是 <code>[key, value]</code>。</p>
</li>
</ul>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">onst obj = { a: 1, b: 2 };
console.log(Object.entries(obj)); // 输出: [['a', 1], ['b', 2]]

</code></pre>
<hr />
<h4><a id="5%C2%A0-object-keys-obj" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(5) <code>Object.keys(obj)</code></strong></h4>
<ul>
<li>
<p><strong>作用</strong>：返回一个对象自身可枚举属性的键名数组。</p>
</li>
<li>
<p><strong>返回值</strong>：字符串数组。</p>
</li>
</ul>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">const obj = { a: 1, b: 2 };
console.log(Object.keys(obj)); // 输出: ['a', 'b']

</code></pre>
<hr />
<h4><a id="6%C2%A0-object-values-obj" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(6) <code>Object.values(obj)</code></strong></h4>
<ul>
<li>
<p><strong>作用</strong>：返回一个对象自身可枚举属性的值数组。</p>
</li>
<li>
<p><strong>返回值</strong>：值数组。</p>
</li>
</ul>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">const obj = { a: 1, b: 2 };
console.log(Object.values(obj)); // 输出: [1, 2]

</code></pre>
<hr />
<h4><a id="7%C2%A0-object-freeze-obj" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(7) <code>Object.freeze(obj)</code></strong></h4>
<ul>
<li>
<p><strong>作用</strong>：冻结一个对象，使其不能被修改（不能添加、删除或修改属性）。</p>
</li>
<li>
<p><strong>返回值</strong>：被冻结的对象。</p>
</li>
</ul>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">const obj = { a: 1 };
Object.freeze(obj);

obj.a = 2; // 无效
console.log(obj.a); // 输出: 1

</code></pre>
<hr />
<h4><a id="8%C2%A0-object-seal-obj" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(8) <code>Object.seal(obj)</code></strong></h4>
<ul>
<li>
<p><strong>作用</strong>：密封一个对象，使其不能添加或删除属性，但可以修改现有属性。</p>
</li>
<li>
<p><strong>返回值</strong>：被密封的对象。</p>
</li>
</ul>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">const obj = { a: 1 };
Object.seal(obj);

obj.a = 2; // 有效
obj.b = 3; // 无效
console.log(obj); // 输出: { a: 2 }
</code></pre>
<hr />
<h4><a id="9%C2%A0-object-is-value1-value2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(9) <code>Object.is(value1, value2)</code></strong></h4>
<ul>
<li>
<p><strong>作用</strong>：比较两个值是否严格相等（类似于 <code>===</code>，但处理 <code>NaN</code> 和 <code>+0/-0</code> 更准确）。</p>
</li>
<li>
<p><strong>返回值</strong>：布尔值。</p>
</li>
</ul>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">console.log(Object.is(NaN, NaN)); // 输出: true
console.log(Object.is(+0, -0));   // 输出: false

</code></pre>
<hr />
<h4><a id="10%C2%A0-object-getprototypeof-obj" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(10) <code>Object.getPrototypeOf(obj)</code></strong></h4>
<ul>
<li>
<p><strong>作用</strong>：返回指定对象的原型。</p>
</li>
<li>
<p><strong>返回值</strong>：对象的原型。</p>
</li>
</ul>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">const proto = {};
const obj = Object.create(proto);

console.log(Object.getPrototypeOf(obj) === proto); // 输出: true
</code></pre>
<hr />
<h3><a id="2%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>2. 实例方法</strong></h3>
<h4><a id="1%C2%A0-obj-hasownproperty-prop" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(1) <code>obj.hasOwnProperty(prop)</code></strong></h4>
<ul>
<li>
<p><strong>作用</strong>：检查对象是否具有指定的自有属性（不包括原型链上的属性）。</p>
</li>
<li>
<p><strong>返回值</strong>：布尔值。</p>
</li>
</ul>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">const obj = { a: 1 };
console.log(obj.hasOwnProperty(&quot;a&quot;)); // 输出: true
console.log(obj.hasOwnProperty(&quot;toString&quot;)); // 输出: false

</code></pre>
<hr />
<h4><a id="2%C2%A0-obj-tostring" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(2) <code>obj.toString()</code></strong></h4>
<ul>
<li>
<p><strong>作用</strong>：返回对象的字符串表示。</p>
</li>
<li>
<p><strong>返回值</strong>：字符串。</p>
</li>
</ul>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">const obj = { a: 1 };
console.log(obj.toString()); // 输出: [object Object]

</code></pre>
<hr />
<h4><a id="3%C2%A0-obj-valueof" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(3) <code>obj.valueOf()</code></strong></h4>
<ul>
<li>
<p><strong>作用</strong>：返回对象的原始值。</p>
</li>
<li>
<p><strong>返回值</strong>：对象的原始值。</p>
</li>
</ul>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">const obj = { a: 1 };
console.log(obj.valueOf()); // 输出: { a: 1 }

</code></pre>
<hr />
<h3><a id="3%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>3. 总结</strong></h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Object.assign()</code></td>
<td>属性到目标对象</td>
<td>目标对象</td>
</tr>
<tr>
<td><code>Object.create()</code></td>
<td>创建新对象，指定原型</td>
<td>新对象</td>
</tr>
<tr>
<td><code>Object.defineProperty()</code></td>
<td>定义或修改属性</td>
<td>目标对象</td>
</tr>
<tr>
<td><code>Object.entries()</code></td>
<td>返回对象的键值对数组</td>
<td>二维数组</td>
</tr>
<tr>
<td><code>Object.keys()</code></td>
<td>返回对象的键名数组</td>
<td>字符串数组</td>
</tr>
<tr>
<td><code>Object.values()</code></td>
<td>返回对象的值数组</td>
<td>值数组</td>
</tr>
<tr>
<td><code>Object.freeze()</code></td>
<td>冻结对象，使其不可修改</td>
<td>被冻结的对象</td>
</tr>
<tr>
<td><code>Object.seal()</code></td>
<td>密封对象，使其不可添加或删除属性</td>
<td>被密封的对象</td>
</tr>
<tr>
<td><code>Object.is()</code></td>
<td>比较两个值是否严格相等</td>
<td>布尔值</td>
</tr>
<tr>
<td><code>Object.getPrototypeOf()</code></td>
<td>返回对象的原型</td>
<td>对象的原型</td>
</tr>
<tr>
<td><code>obj.hasOwnProperty()</code></td>
<td>检查对象是否具有指定的自有属性</td>
<td>布尔值</td>
</tr>
<tr>
<td><code>obj.toString()</code></td>
<td>返回对象的字符串表示</td>
<td>字符串</td>
</tr>
<tr>
<td><code>obj.valueOf()</code></td>
<td>返回对象的原始值</td>
<td>原始值</td>
</tr>
</tbody>
</table>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JS：原型和原型链]]></title>
    <link href="justbb.fun/17420542537025.html"/>
    <updated>2025-03-15T23:57:33+08:00</updated>
    <id>justbb.fun/17420542537025.html</id>
    <content type="html">
<![CDATA[<p><strong>原型</strong> 和 <strong>原型链</strong> 是 JavaScript 中实现继承和共享属性的核心机制。<br />
理解 <code>[[Prototype]]</code>、<code>prototype</code> 和 <code>constructor</code> 的关系，是掌握 JavaScript 面向对象编程的关键。</p>
<p><img src="media/17420542537025/%E9%9C%80%E6%B1%82%E8%B0%83%E7%A0%94.jpg" alt="需求调研" /></p>
<h3><a id="1%C2%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%C2%A0-prototype%C2%A0%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. <strong>对象的 <code>[[Prototype]]</code> 属性</strong></h3>
<ul>
<li>每个对象（对象实例）都有一个内部属性 <code>[[Prototype]]</code>，默认指向一个对象。</li>
<li>这个对象（称为原型对象），它包含可以由该函数创建的所有实例共享的属性和方法。</li>
<li>这个 <code>[[Prototype]]</code> 属性可以通过 <code>Object.getPrototypeOf(obj)</code> 或 <code>obj.__proto__</code> 访问。</li>
<li>如果对象是通过字面量创建的，<code>[[Prototype]]</code> 默认指向 <code>Object.prototype</code>。</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">const obj = {};
console.log(Object.getPrototypeOf(obj) === Object.prototype); // 输出: true
console.log(obj.__proto__ === Object.prototype); // 输出: true
</code></pre>
<hr />
<h3><a id="2%C2%A0-new%C2%A0%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. <strong><code>new</code> 关键字和构造函数</strong></h3>
<ul>
<li>
<p>当使用 <code>new</code> 关键字调用构造函数时，会创建一个新的对象。</p>
</li>
<li>
<p>这个新对象的 <code>[[Prototype]]</code> 属性会被设置为构造函数的 <code>prototype</code> 属性指向的对象。</p>
</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">function Person(name) {
  this.name = name;
}

const alice = new Person('Alice');
console.log(Object.getPrototypeOf(alice) === Person.prototype); // 输出: true
console.log(alice.__proto__ === Person.prototype); // 输出: true
</code></pre>
<ul>
<li>
<p><strong>解释</strong>：</p>
<ul>
<li>
<p><code>alice</code> 是通过 <code>new Person()</code> 创建的对象。</p>
</li>
<li>
<p><code>alice</code> 的 <code>[[Prototype]]</code> 属性指向 <code>Person.prototype</code>。</p>
</li>
</ul>
</li>
</ul>
<hr />
<h3><a id="3%C2%A0%E5%87%BD%E6%95%B0%E7%9A%84%C2%A0-prototype%C2%A0%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. <strong>函数的 <code>prototype</code> 属性</strong></h3>
<ul>
<li>
<p>每个函数都有一个 <code>prototype</code> 属性，这个属性是一个对象，这个对象是实例的原型</p>
</li>
<li>
<p>这个 <code>prototype</code> 对象有一个 <code>constructor</code> 属性，指向函数本身。</p>
</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">function Person(name) {
  this.name = name;
}

console.log(Person.prototype.constructor === Person); // 输出: true
</code></pre>
<ul>
<li>
<p><strong>解释</strong>：</p>
<ul>
<li><code>Person.prototype</code> 是一个对象，它的 <code>constructor</code> 属性指向 <code>Person</code> 函数本身。</li>
</ul>
</li>
</ul>
<hr />
<h3><a id="4%C2%A0%E5%8E%9F%E5%9E%8B%E9%93%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. <strong>原型链</strong></h3>
<ul>
<li>当访问对象的属性或方法时，如果对象本身没有该属性或方法，JavaScript 会沿着 <code>[[Prototype]]</code> 链向上查找，直到找到该属性或方法，或者到达原型链的尽头（<code>null</code>）。</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">function Person(name) {
  this.name = name;
}

// 在 Person.prototype 上添加方法
Person.prototype.sayHello = function() {
  console.log(`Hello, my name is ${this.name}`);
};

const alice = new Person('Alice');
alice.sayHello(); // 输出: Hello, my name is Alice
</code></pre>
<ul>
<li>
<p><strong>解释</strong>：</p>
<ul>
<li>
<p><code>alice</code> 本身没有 <code>sayHello</code> 方法，但它的 <code>[[Prototype]]</code> 指向 <code>Person.prototype</code>，而 <code>Person.prototype</code> 上有 <code>sayHello</code> 方法。</p>
</li>
<li>
<p>因此，<code>alice</code> 可以调用 <code>sayHello</code> 方法。</p>
</li>
</ul>
</li>
</ul>
<hr />
<h3><a id="5%C2%A0%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E5%B0%BD%E5%A4%B4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5. <strong>原型链的尽头</strong></h3>
<ul>
<li>
<p>原型链的尽头是 <code>null</code>。</p>
</li>
<li>
<p><code>Object.prototype</code> 是大多数对象的原型链的终点，它的 <code>[[Prototype]]</code> 是 <code>null</code>。</p>
</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">console.log(Object.getPrototypeOf(Object.prototype)); // 输出: null
</code></pre>
<hr />
<h3><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h3>
<ol>
<li>
<p><strong><code>[[Prototype]]</code></strong>：</p>
<ul>
<li>
<p>每个对象都有一个 <code>[[Prototype]]</code> 属性，指向它的原型对象。</p>
</li>
<li>
<p>默认情况下，对象的 <code>[[Prototype]]</code> 指向 <code>Object.prototype</code>。</p>
</li>
</ul>
</li>
<li>
<p><strong><code>new</code> 关键字</strong>：</p>
<ul>
<li>使用 <code>new</code> 关键字调用构造函数时，新对象的 <code>[[Prototype]]</code> 会被设置为构造函数的 <code>prototype</code> 属性指向的对象。</li>
</ul>
</li>
<li>
<p><strong>函数的 <code>prototype</code> 属性</strong>：</p>
<ul>
<li>
<p>每个函数都有一个 <code>prototype</code> 属性，指向一个对象。</p>
</li>
<li>
<p>这个对象的 <code>constructor</code> 属性指向函数本身。</p>
</li>
</ul>
</li>
<li>
<p><strong>原型链</strong>：</p>
<ul>
<li>当访问对象的属性或方法时，JavaScript 会沿着 <code>[[Prototype]]</code> 链向上查找，直到找到该属性或方法，或者到达 <code>null</code>。</li>
</ul>
</li>
</ol>
<hr />
<h3><a id="%E5%9B%BE%E7%A4%BA%E5%8E%9F%E5%9E%8B%E9%93%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>图示原型链</h3>
<p>以下是一个简单的原型链图示：</p>
<pre><code class="language-plain_text">alice (实例对象)
  |
  | [[Prototype]]
  v
Person.prototype
  |
  | [[Prototype]]
  v
Object.prototype
  |
  | [[Prototype]]
  v
null
</code></pre>
<ul>
<li>
<p><code>alice</code> 是 <code>Person</code> 的实例，它的 <code>[[Prototype]]</code> 指向 <code>Person.prototype</code>。</p>
</li>
<li>
<p><code>Person.prototype</code> 的 <code>[[Prototype]]</code> 指向 <code>Object.prototype</code>。</p>
</li>
<li>
<p><code>Object.prototype</code> 的 <code>[[Prototype]]</code> 指向 <code>null</code>。</p>
</li>
</ul>
<hr />
<h3><a id="%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例代码</h3>
<p>以下是一个完整的示例，展示原型链的工作原理：</p>
<pre><code class="language-javascript">function Person(name) {
  this.name = name;
}

// 在 Person.prototype 上添加方法
Person.prototype.sayHello = function() {
  console.log(`Hello, my name is ${this.name}`);
};

const alice = new Person('Alice');

// 访问属性和方法
console.log(alice.name); // 输出: Alice
alice.sayHello(); // 输出: Hello, my name is Alice

// 检查原型链
console.log(Object.getPrototypeOf(alice) === Person.prototype); // 输出: true
console.log(Object.getPrototypeOf(Person.prototype) === Object.prototype); // 输出: true
console.log(Object.getPrototypeOf(Object.prototype) === null); // 输出: true

</code></pre>
<hr />
<h3><a id="%E7%A4%BA%E4%BE%8B%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例图</h3>
<pre><code class="language-javascript">// 把这个代码中的原型链绘制出来，绘制到null为止

class Fruit { }

class Apple extends Fruit { }

class Grape extends Fruit { }

class Hongfushi extends Apple { }

const apple = new Apple();
</code></pre>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JS：数组综合练习]]></title>
    <link href="justbb.fun/17419571663740.html"/>
    <updated>2025-03-14T20:59:26+08:00</updated>
    <id>justbb.fun/17419571663740.html</id>
    <content type="html">
<![CDATA[<pre><code class="language-javascript">/* 
练习1:
定义一个构造函数 一个参数
使用该构造函数 配合new 会产生有一个属性age的实例对象
let arr = [12,41,20,66,35,70]
利用上面数组中的数据，产出一个新组
数组中都是该构造函数的实例，实例的age值依次分别数arr这个数组中的数据
同时 最终的数组中的对象顺序 要按照age属性的值从小到大排列 */&lt;!----&gt;

let arr1 = [12,41,20,66,35,70]

function PersonAge(age) {
    this.age = age
}
/*
//方法一
let newArr = []
 
arr1.forEach((ele)=&gt;{
    newArr.push(new PersonAge(ele))
})

newArr.sort((a,b)=&gt;a.age-b.age) */

//方法二
const newArr = arr1.map((ele)=&gt; new PersonAge(ele)).sort((a,b)=&gt;a.age-b.age)

console.log(newArr);

</code></pre>
<pre><code class="language-javascript">/* 
练习2:
定义一个函数，函数有两个参数，参数传入有数据的数组
会比较这传入的两个数组中是否有相同（严格相等）的数据有 函数返回true
没有 返回false

*/
const arra = ['tom'];
const arrb = ['a', 'b', 'c', 1, 2, 3, 4];

function testArr(arr1, arr2) {
  const result = arr1.findIndex((ele1) =&gt; {
    // 检查 ele1 是否在 arr2 中
    return arr2.includes(ele1);
  });

  console.log(result); // 输出找到的索引，未找到则为 -1

  if (result !== -1) {
    console.log(true);
  } else {
    console.log(false);
  }
}

testArr(arra, arrb); // 输出: -1, false

-------

arra = [1,'tom']
arrb = ['a','b','c',1,2,3,4]

function testArr(arr1,arr2) {
    const result = arr1.findIndex((ele1,index1,array1) =&gt; {
        const result2 = arr2.findIndex((ele2,index2,array2) =&gt; {
        return ele2 === ele1
    })

        if (result2 !== -1) {
            return true
        }else{
            return false
        }

    })
    
    if (result !== -1) {
        return true
    }else{
        return false
    }
 
}

console.log(testArr(arra,arrb));

---------

arra = [0,'tom',2]
arrb = ['a','b','c',1,2,3,4]

function testArr(arr1,arr2) {
    const result = arr1.findIndex(
        (ele)=&gt;{
            return arr2.includes(ele)
        }
    )
    console.log(result);
    
    if (result !== -1) {
        console.log(true);
    }else{
        console.log(false);
    }
    
 
}

console.log(testArr(arra,arrb));

---------
// 最合理的方案
const arra = [0, 'tom', 2];
const arrb = ['a', 'b', 'c', 1, 2, 3, 4];

function testArr(arr1, arr2) {
  const result = arr1.some((ele) =&gt; arr2.includes(ele)); // 检查是否存在匹配元素
  console.log(result); // 直接输出 true 或 false
}

testArr(arra, arrb); // 输出: true

</code></pre>
<pre><code class="language-javascript">let arr = [
    {name:'小明',score:60},
    {name:'小花',score:81},
    {name:'小亮',score:62},
    {name:'小章',score:73},
    {name:'小李',score:66},
    {name:'小胖',score:92},
]
// 练习3:
// 定义一个函数 可以传入一个数组 和 一个字符串这个函数执行时 可以筛选出数组中分数低于80分的对象 然后给该对象 设置一个属性 叫做 label 这个属性的值就是传入的第二个参数 字符串
// 同时 要创建一个新的数组 用深克隆的方式 按原数组相反的顺序 复制这些对象数据到新的的数组中
// 最后 还要在这个新数组的最后加上一个 所有对象的score总分的数据 数字类型的数据
// 函数执行完之后把这个新数组返回

function testArr(arr,str) {
    const newArr = arr.filter((ele)=&gt;ele.score&lt;80
    )
    
    newArr.forEach(element =&gt; {
        element.lable = str
    });

    arr.reverse()
    

    const result = arr.map(ele=&gt;{
        return{
            ...ele
        }//创建了新对象，也就开辟了新的内存空间，与原对象不影响，创建的新对象会被添加到map方法执行后要返回的新对象中
    })

    return result

    arr[1].lable = '测试' //测试是否arr和resutl引用的是不是同一数据

    console.log(result);
    console.log(arr);
    
}
testArr(arr,'不太好')
// console.log(newArr);

</code></pre>
<pre><code class="language-javascript">// 练习 4
// 定义一个函数 传入两个参数，第一个是数组 第二个传某个数据
// 执行时传入上述这样结构的数组 和 一个你筛选的数据
// 筛选出数组中 和 传入进行筛选数据严格相等的数据
// 统计一共有多少个 返回 数量

let arr1 = [[1,2,3,'s','m','6',true],[1,1,32,'s2','木','6',false]]


function countArr(arr,data) {
    const  newArr = []
    arr.forEach(element =&gt; {
        element.forEach(ele=&gt;
            newArr.push(ele)
        );
        
    });
    console.log(newArr);
    let count = 0
    let idx = newArr.indexOf(data)
    while(idx!==-1) {
        idx = newArr.indexOf(data,idx+1)
        count++

    }
    console.log(count);

}

countArr(arr1,'6')

-------------

let arr1 = [
  [1, 2, 3, 's', 'm', '6', true],
  [1, 1, 32, 's2', '木', '6', false]
];

function countArr(arr, data) {
  // 使用 flat() 方法将二维数组扁平化
  const newArr = arr.flat();
  
  // 使用 filter() 方法统计 data 出现的次数
  const count = newArr.filter(item =&gt; item === data).length;
  
  console.log(`元素 &quot;``{data}&quot; 出现的次数为: ``{count}`);
}

countArr(arr1, '6'); // 输出: 元素 &quot;6&quot; 出现的次数为: 2

-------

let arr1 = [[1,2,3,'s','m','6',true],[1,1,32,'s2','木','6',false]]


function countArr(arr,data) {
    let  newArr = []
    arr.forEach(ele =&gt; {
        const tempArr = ele.filter(
            (item)=&gt;item === data
        )
        newArr = newArr.concat(tempArr)
    });
    
    console.log(newArr.length);
    
    
    
}

countArr(arr1,'6')

</code></pre>
<pre><code class="language-javascript">
// 练习5
// 根据这个数组 创建一个新数组
// 这个新数组 的每一位数据 都是这个原数组相应索引位的值 与下一位索引位的值的和
// 如果是最后一位 那就是和第一位的和

let arr1 = [1,2,3,4,5,6,7,8,9]

let arr2 = arr1.map((ele,index)=&gt;{
    if (index === arr1.length-1) {
        return arr1[index]+arr1[0]
    }else{
        return arr1[index+1]+ele
    }
    
})

console.log(arr2);

</code></pre>
<pre><code class="language-javascript">// 练习6
// 定义一个函数 一个参数
// 可以把传入的数组
// 按照不同的数据类型进行不同的处理
// 如果是数字类型 把所有数字类型相加
// 如果是字符串 所有字符串拼接到一起
// 其他类型都忽略
// 然后 加总的数字 和 拼接的字符串 添加到原数组的后面
// 返回原数组

let arr1 = [[1,2],1,2,3,'你好','笨蛋',{a:12},true]

function testArr(arr) {
    let temp1 =  arr1.filter((ele)=&gt;typeof ele === 'number')
    let temp2 =  arr1.filter((ele)=&gt;typeof ele === 'string')
    let result1 = temp1.reduce((a,b)=&gt;a+b)
    let result2 = temp2.join('')
    arr1.push(result1,result2)
    console.log(arr1);
    
}

testArr(arr1)
---------------
let arr1 = [[1,2],1,2,3,'你好','笨蛋',{a:12},true]

function testArr(arr) {
    let strTotal = ''
    let numTotal = 0
    arr.forEach((ele)=&gt;{
        if (typeof ele === 'string') {
            strTotal += ele
        }else if(typeof ele === 'number'){
            numTotal += ele
        }
    })

    arr.push(strTotal,numTotal)
    return arr
}


console.log(testArr(arr1));


</code></pre>
<pre><code class="language-javascript">// 练习7
// 定义一个函数 可以传入一个字符串
// 然后把字符串拆成一个个的字符
// 倒序放到一个数组中

let str = 'helloworld'

function strArr(str) {
    const arr = [...str]
    arr.reverse()
    console.log(arr);
    
}

strArr(str)


</code></pre>
<pre><code class="language-javascript">// 练习8
// 定义一个函数 两个参数 可以传入一个数组，和 一个数据类型的字符串 string number
// 函数执行时 如果 数组中有传入的数据类型
// 那么要把数组中所有数据全变成该类型的字符串名称
// 没有该类型数据的话
// 要把数组清空
// 最后返回这个原数组数组

let arr1 = [1,2,3,4,'3','23',true]

function testArr(arr,type) {
    const hasType = arr.some((ele)=&gt;typeof ele === type)
    if (hasType) {
        arr.fill(type)
    }else{
        arr.length = 0
    }
}

testArr(arr1,'object')
console.log(arr1);

</code></pre>
<pre><code class="language-javascript">
// 练习9
// 定义一个函数 传入两个参数 第一个数组 第二个是类型字符串
// 函数执行时 会把原数组中的所有非第二个参数类型名称的数据都删掉
// 这些删掉的数据会组成一个新数组
// 返回 新数组的长度

let arr = [1,'1',2,3,'s','m','6',true]

function handleArr(arr,typeStr) {
    
    let newArr = arr.map((ele,index)=&gt; {
        if (typeof ele === typeStr) {
            return index
        }
    }).filter(ele=&gt;ele !== undefined)
    
    arr = arr.filter(ele=&gt;typeof ele !== typeStr)

    console.log(newArr.length);
    console.log(arr);
    
    

}

handleArr(arr,'string')

-----------

// 练习9
// 定义一个函数 传入两个参数 第一个数组 第二个是类型字符串
// 函数执行时 会把原数组中的所有非第二个参数类型名称的数据都删掉
// 这些删掉的数据会组成一个新数组
// 返回 新数组的长度

let arr = [1,'1',2,3,'s','m','6',true]

function handleArr(arr,typeStr) {
    
    let newArr = arr.map((ele,index)=&gt; {
        if (typeof ele === typeStr) {
            return index
        }
    }).filter(ele=&gt;ele !== undefined)
    let spliceCount = 0
    // arr = arr.filter(ele=&gt;typeof ele !== typeStr)
    newArr.forEach(ele =&gt; {
        arr.splice(ele-spliceCount,1)
        spliceCount++;
    });

    console.log(newArr.length);
    console.log(arr); 

}

handleArr(arr,'string')
</code></pre>
<pre><code class="language-javascript">// 练习10
// 定义一个函数 可以传入这样一个数组
// 计算出这个数组中所有数字类型数据的总和的值
// 并把所有非数字类型的数据组成一个新数组
// 返回新数组

let arr = [1,[2,4],5,[6,'true',1],[6,10],true]

/* function numTotal(arr) {
    const newArr = arr.flat()
    console.log(newArr);

    const newArr2 = newArr.filter((ele)=&gt;typeof ele === 'number')
    const result = newArr2.reduce((a,b)=&gt;a+b)
    console.log(result);
}
 */

function numTotal(arr) {
    let total = 0
    let result =[]
    arr.forEach(ele =&gt; {
        if (typeof ele === 'number') {
            total += ele            
        }else if(ele instanceof Array){
            ele.forEach(ele1=&gt;{
                if (typeof ele1 === 'number') {
                    total += ele1
                }else{
                    result.push(ele1)
                }
            })
        }else{
            result.push(ele)
        }
    });

    console.log(total);
    console.log(result);
    
}

numTotal(arr)

</code></pre>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[成长股的卖出逻辑]]></title>
    <link href="justbb.fun/17419272058320.html"/>
    <updated>2025-03-14T12:40:05+08:00</updated>
    <id>justbb.fun/17419272058320.html</id>
    <content type="html">
<![CDATA[<p>成长股一般看动态市盈率。</p>
<h3><a id="1%E5%8A%A8%E6%80%81%E5%B8%82%E7%9B%88%E7%8E%87%E7%9A%84%E6%84%8F%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. 动态市盈率的意义</h3>
<p>动态市盈率是基于公司未来盈利预测计算的市盈率，反映了市场对公司未来增长的预期。对于成长股来说，动态市盈率是一个重要的估值指标，因为成长股的当前盈利可能较低，但未来盈利增长潜力较大。</p>
<p><strong>20-30倍动态市盈率：</strong> 这是一个常见的合理区间，尤其适用于高增长行业（如科技、医药等）。如果公司未来盈利增长能够支撑这一估值，那么股价仍有上涨空间。<br />
小于20倍：如果动态市盈率低于20倍，可能意味着市场低估了公司的成长潜力，或者公司增长放缓。你选择不卖出，是基于对公司未来增长的信心。</p>
<h3><a id="2%E5%8D%96%E5%87%BA%E6%97%B6%E6%9C%BA%E7%9A%84%E8%80%83%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. 卖出时机的考量</h3>
<p>你提到“除非有时候涨得太厉害”，这意味着你也会考虑股价的短期涨幅。以下是一些可能影响卖出决策的因素：</p>
<p>（1）估值过高</p>
<p>如果动态市盈率远高于30倍（例如超过50倍），可能意味着股价已经透支了未来几年的增长预期，存在回调风险。<br />
可以参考行业平均市盈率，如果远高于行业平均水平，可能需要谨慎。</p>
<p>（2）技术面超买<br />
如果股价短期内涨幅过大（例如超过50%或100%），可能会出现技术性回调。<br />
可以结合技术指标（如RSI、MACD）来判断是否超买。</p>
<p>（3）基本面变化<br />
如果公司的基本面发生变化（如业绩增速放缓、行业竞争加剧、管理层变动等），即使动态市盈率仍在合理区间，也可能需要考虑卖出。</p>
<p>目前持有快手-W，药明康德</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[小米电视设置ADB常用命令]]></title>
    <link href="justbb.fun/17420096800849.html"/>
    <updated>2025-03-15T11:34:40+08:00</updated>
    <id>justbb.fun/17420096800849.html</id>
    <content type="html">
<![CDATA[<p>通过 ADB 操作电视</p>
<pre><code class="language-python">adb connect 192.168.1.2
#查看自己电视IP并连接，注意在电视上点击确实

adb install D:\ATV.apk
#自行下载ATV Launcher Pro后，执行以上命令安装D:\ATV.apk到电视，并手动设置为系统桌面

adb shell pm uninstall -k --user 0 com.mitv.tvhome
#卸载小米桌面，如果想备份小米桌面App要自行下载安装Apk Extractor导出保存
</code></pre>
<p>一些或许会用到的ADB命令</p>
<pre><code class="language-python">
adb shell pm list packages
#列出所有应用
 
adb shell pm list packages -s
#列出系统应用
 
adb shell pm list packages -3
#列出第三方应用
 
adb shell pm list packages -d
#列出已禁用应用
 
adb shell pm list packages -e
#列出已启用应用

adb shell dumpsys package com.mitv.tvhome
#查询应用详细信息

adb shell pm path com.mitv.tvhome
#查看应用安装路径

adb install D:\bilibili.apk
#安装D:\bilibili.apk到电视

adb install -s D:\bilibili.apk
#将应用安装到 SD 存储卡 

adb install -r D:\bilibili.apk
#允许覆盖安装
 
adb install -d D:\bilibili.apk
#允许降级覆盖安装
 
adb install -g D:\bilibili.apk
#允许应用所需全部权限

adb shell pm disable-user com.mitv.tvhome
#禁用某应用

adb shell pm enable com.mitv.tvhome
#恢复某应用

adb shell pm uninstall -k --user 0 com.mitv.tvhome
#卸载某应用

adb shell am force-stop com.mitv.tvhome
#强制停止某应用

adb push D:\bilibili.apk /sdcard/
#将D盘bilibili.apk文件传输到电视sdcard目录

adb pull /sdcard/bilibili.apk D:\Download
#将电视sdcard目录的bilibili.apk文件传输到电脑D:\Download

adb reboot
#重启系统

adb reboot recovery
#重启到 Recovery 模式

adb reboot bootloader
#重启到 Fastboot 模式 

</code></pre>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JS：函数是一种特殊对象]]></title>
    <link href="justbb.fun/17420533060973.html"/>
    <updated>2025-03-15T23:41:46+08:00</updated>
    <id>justbb.fun/17420533060973.html</id>
    <content type="html">
<![CDATA[<h4><a id="1%C2%A0%E5%87%BD%E6%95%B0%E6%98%AF%C2%A0-function%C2%A0%E7%9A%84%E5%AE%9E%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. <strong>函数是 <code>Function</code> 的实例</strong></h4>
<ul>
<li>
<p>在 JavaScript 中，函数是通过 <code>Function</code> 构造函数创建的。</p>
</li>
<li>
<p>每个函数都是 <code>Function</code> 类型的实例，而 <code>Function</code> 是 <code>Object</code> 的子类型。</p>
</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">function foo() {
  console.log('Hello, world!');
}

console.log(foo instanceof Function); // 输出: true
console.log(foo instanceof Object);   // 输出: true
</code></pre>
<ul>
<li>
<p><strong>解释</strong>：</p>
<ul>
<li><code>foo</code> 是 <code>Function</code> 的实例，同时也是 <code>Object</code> 的实例。</li>
</ul>
</li>
</ul>
<hr />
<h4><a id="2%C2%A0%E5%87%BD%E6%95%B0%E5%85%B7%E6%9C%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. <strong>函数具有对象的特性</strong></h4>
<ul>
<li>
<p>函数可以像普通对象一样拥有属性和方法。</p>
</li>
<li>
<p>函数可以作为参数传递，也可以作为返回值。</p>
</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">function foo() {
  console.log('Hello, world!');
}

// 为函数添加属性
foo.name = 'myFunction';
foo.description = 'This is a function';

console.log(foo.name); // 输出: myFunction
console.log(foo.description); // 输出: This is a function

// 将函数作为参数传递
function bar(func) {
  func();
}

bar(foo); // 输出: Hello, world!
</code></pre>
<ul>
<li>
<p><strong>解释</strong>：</p>
<ul>
<li>
<p>函数 <code>foo</code> 可以像普通对象一样添加属性。</p>
</li>
<li>
<p>函数 <code>foo</code> 可以作为参数传递给另一个函数 <code>bar</code>。</p>
</li>
</ul>
</li>
</ul>
<hr />
<h4><a id="3%C2%A0%E5%87%BD%E6%95%B0%E6%98%AF%E2%80%9C%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91%E2%80%9D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. <strong>函数是“一等公民”</strong></h4>
<ul>
<li>
<p>在 JavaScript 中，函数是“一等公民”（First-class Citizen），这意味着函数可以：</p>
<ul>
<li>
<p>赋值给变量。</p>
</li>
<li>
<p>作为参数传递给其他函数。</p>
</li>
<li>
<p>作为返回值从其他函数中返回。</p>
</li>
<li>
<p>存储在数据结构中（如数组、对象）。</p>
</li>
</ul>
</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">// 赋值给变量
const myFunc = function() {
  console.log('Hello, world!');
};

// 作为参数传递
function callFunction(func) {
  func();
}

callFunction(myFunc); // 输出: Hello, world!

// 作为返回值
function createFunction() {
  return function() {
    console.log('This is a new function!');
  };
}

const newFunc = createFunction();
newFunc(); // 输出: This is a new function!
</code></pre>
<h4><a id="4%C2%A0%E5%87%BD%E6%95%B0%E6%98%AF%E2%80%9C%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E2%80%9D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. <strong>函数是“可调用对象”</strong></h4>
<ul>
<li>函数是一种特殊的对象，它不仅可以拥有属性和方法，还可以被调用（通过 <code>()</code> 调用）。</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">function foo() {
  console.log('Hello, world!');
}

// 调用函数
foo(); // 输出: Hello, world!

// 为函数添加属性
foo.description = 'This is a function';
console.log(foo.description); // 输出: This is a function
</code></pre>
<hr />
<h3><a id="%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E6%AE%8A%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>函数的特殊属性</h3>
<p>函数作为对象，具有一些特殊的属性：</p>
<ol>
<li>
<p><strong><code>name</code></strong>：</p>
<ul>
<li>
<p>函数的名称。</p>
</li>
<li>
<p>例如：</p>
</li>
</ul>
<pre><code class="language-javascript"> function foo() {}
 console.log(foo.name); // 输出: foo
</code></pre>
</li>
<li>
<p><strong><code>length</code></strong>：</p>
<ul>
<li>
<p>函数期望的参数个数。</p>
</li>
<li>
<p>例如：</p>
</li>
</ul>
<pre><code class="language-javascript"> function bar(a, b, c) {}
 console.log(bar.length); // 输出: 3
</code></pre>
</li>
<li>
<p><strong><code>prototype</code></strong>：</p>
<ul>
<li>
<p>函数的 <code>prototype</code> 属性指向一个对象，这个对象是构造函数创建的实例的原型。</p>
</li>
<li>
<p>例如：</p>
</li>
</ul>
<pre><code class="language-javascript"> function Person(name) {
     this.name = name;
 }
 console.log(Person.prototype); // 输出: { constructor: Person }
</code></pre>
</li>
</ol>
<hr />
<h3><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h3>
<ul>
<li>
<p>函数是 JavaScript 中的一种对象，是 <code>Function</code> 类型的实例。</p>
</li>
<li>
<p>函数具有对象的所有特性，可以拥有属性和方法，可以作为参数传递，也可以作为返回值。</p>
</li>
<li>
<p>函数是“一等公民”，是“可调用对象”。</p>
</li>
<li>
<p>理解函数是对象这一特性，是掌握 JavaScript 函数式编程和面向对象编程的关键。</p>
</li>
</ul>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JS：对象与属性]]></title>
    <link href="justbb.fun/17421324023459.html"/>
    <updated>2025-03-16T21:40:02+08:00</updated>
    <id>justbb.fun/17421324023459.html</id>
    <content type="html">
<![CDATA[<p>在 JavaScript 中，<strong>对象</strong>和<strong>属性</strong>是紧密相关的概念。对象是属性的容器，而属性是对象的组成部分。以下是关于对象与属性关系的详细解释：</p>
<hr />
<h3><a id="1%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>1. 对象是什么？</strong></h3>
<ul>
<li>
<p><strong>对象</strong>是 JavaScript 中的一种复合数据类型，用于存储多个键值对（Key-Value Pair）。</p>
</li>
<li>
<p>对象可以包含任意数量的属性，每个属性都有一个名称（键）和一个值。</p>
</li>
<li>
<p>对象是动态的，可以随时添加、修改或删除属性。</p>
</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">const person = {
  name: &quot;Alice&quot;,
  age: 25,
  greet() {
    console.log(`Hello, my name is ${this.name}`);
  }
};
</code></pre>
<hr />
<h3><a id="2%E5%B1%9E%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>2. 属性是什么？</strong></h3>
<ul>
<li>
<p><strong>属性</strong>是对象的组成部分，用于描述对象的状态或行为。</p>
</li>
<li>
<p>属性由键值对组成：</p>
<ul>
<li>
<p><strong>键</strong>（Key）：属性的名称，通常是字符串或符号。</p>
</li>
<li>
<p><strong>值</strong>（Value）：属性的具体数据，可以是任何类型（如字符串、数字、布尔值、函数、对象等）。</p>
</li>
</ul>
</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">const person = {
  name: &quot;Alice&quot;, // 属性 name，值为 &quot;Alice&quot;
  age: 25,       // 属性 age，值为 25
  greet() {      // 属性 greet，值为一个函数
    console.log(`Hello, my name is ${this.name}`);
  }
};
</code></pre>
<hr />
<h3><a id="3%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%B1%9E%E6%80%A7%E7%9A%84%E5%85%B3%E7%B3%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>3. 对象与属性的关系</strong></h3>
<ul>
<li>
<p><strong>对象是属性的容器</strong>：对象通过属性来存储数据和定义行为。</p>
</li>
<li>
<p><strong>属性是对象的组成部分</strong>：属性描述了对象的状态（数据）和行为（方法）。</p>
</li>
</ul>
<h4><a id="%E5%85%B3%E7%B3%BB%E6%80%BB%E7%BB%93%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>关系总结：</h4>
<ol>
<li>
<p><strong>对象包含属性</strong>：</p>
<ul>
<li>
<p>对象可以包含多个属性。</p>
</li>
<li>
<p>属性可以是数据属性（存储数据）或方法属性（定义行为）。</p>
</li>
</ul>
</li>
<li>
<p><strong>属性属于对象</strong>：</p>
<ul>
<li>
<p>属性是对象的组成部分，不能脱离对象单独存在。</p>
</li>
<li>
<p>属性通过对象访问和操作。</p>
</li>
</ul>
</li>
</ol>
<hr />
<h3><a id="4%E5%B1%9E%E6%80%A7%E7%9A%84%E5%88%86%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>4. 属性的分类</strong></h3>
<p>属性可以分为以下几类：</p>
<h4><a id="1%E6%95%B0%E6%8D%AE%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(1) 数据属性</strong></h4>
<ul>
<li>
<p>直接存储数据的属性。</p>
</li>
<li>
<p>包含一个值（Value）和一组描述其行为的特性（Attributes），如：</p>
<ul>
<li>
<p><code>value</code>：属性的值。</p>
</li>
<li>
<p><code>writable</code>：是否可修改。</p>
</li>
<li>
<p><code>enumerable</code>：是否可枚举（例如，是否会在 <code>for...in</code> 循环中出现）。</p>
</li>
<li>
<p><code>configurable</code>：是否可删除或修改特性。</p>
</li>
</ul>
</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">const obj = {
  name: &quot;Alice&quot; // 数据属性
};
</code></pre>
<hr />
<h4><a id="2%E8%AE%BF%E9%97%AE%E5%99%A8%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(2) 访问器属性</strong></h4>
<ul>
<li>
<p>不直接存储值，而是通过 <code>getter</code> 和 <code>setter</code> 方法访问和设置值。</p>
</li>
<li>
<p>包含 <code>get</code> 和 <code>set</code> 方法。</p>
</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">const obj = {
  _age: 25, // 内部属性
  get age() {
    return this._age;
  },
  set age(value) {
    if (value &gt; 0) {
      this._age = value;
    }
  }
};

console.log(obj.age); // 输出: 25
obj.age = 30;
console.log(obj.age); // 输出: 30

</code></pre>
<hr />
<h4><a id="3%E5%86%85%E7%BD%AE%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(3) 内置属性</strong></h4>
<ul>
<li>
<p>JavaScript 对象本身具有的一些特殊属性，例如：</p>
<ul>
<li>
<p><code>__proto__</code>：指向对象的原型。</p>
</li>
<li>
<p><code>constructor</code>：指向创建对象的构造函数。</p>
</li>
</ul>
</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">const obj = {};
console.log(obj.__proto__); // 输出: Object.prototype
console.log(obj.constructor); // 输出: ƒ Object()

</code></pre>
<hr />
<h3><a id="5%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>5. 对象的属性操作</strong></h3>
<p>可以通过以下方式操作对象的属性：</p>
<h4><a id="1%E8%AE%BF%E9%97%AE%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(1) 访问属性</strong></h4>
<ul>
<li>使用点符号（<code>.</code>）或方括号（<code>[]</code>）访问属性。</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">const person = {
  name: &quot;Alice&quot;
};

console.log(person.name); // 输出: Alice
console.log(person[&quot;name&quot;]); // 输出: Alice
</code></pre>
<hr />
<h4><a id="2%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(2) 添加属性</strong></h4>
<ul>
<li>直接为对象赋值一个新属性。</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">const person = {};
person.name = &quot;Alice&quot;;
console.log(person.name); // 输出: Alice

</code></pre>
<hr />
<h4><a id="3%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(3) 修改属性</strong></h4>
<ul>
<li>直接为已有属性赋值。</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">const person = {
  name: &quot;Alice&quot;
};

person.name = &quot;Bob&quot;;
console.log(person.name); // 输出: Bob
</code></pre>
<hr />
<h4><a id="4%E5%88%A0%E9%99%A4%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(4) 删除属性</strong></h4>
<ul>
<li>使用 <code>delete</code> 操作符删除属性。</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">const person = {
  name: &quot;Alice&quot;
};

delete person.name;
console.log(person.name); // 输出: undefined

</code></pre>
<hr />
<h4><a id="5%E6%A3%80%E6%9F%A5%E5%B1%9E%E6%80%A7%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(5) 检查属性是否存在</strong></h4>
<ul>
<li>使用 <code>in</code> 操作符或 <code>hasOwnProperty</code> 方法。</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">const person = {
  name: &quot;Alice&quot;
};

console.log(&quot;name&quot; in person); // 输出: true
console.log(person.hasOwnProperty(&quot;name&quot;)); // 输出: true

</code></pre>
<hr />
<h3><a id="6%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%B1%9E%E6%80%A7%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>6. 对象与属性的实际应用</strong></h3>
<ul>
<li>
<p><strong>数据存储</strong>：对象用于存储结构化数据，属性用于描述数据的各个部分。</p>
</li>
<li>
<p><strong>行为定义</strong>：对象的方法属性用于定义对象的行为。</p>
</li>
<li>
<p><strong>动态扩展</strong>：对象可以动态添加、修改或删除属性，使其非常灵活。</p>
</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">const car = {
  brand: &quot;Toyota&quot;,
  model: &quot;Corolla&quot;,
  drive() {
    console.log(`Driving ``{this.brand} ``{this.model}`);
  }
};

car.drive(); // 输出: Driving Toyota Corolla
</code></pre>
<hr />
<h3><a id="7%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>7. 总结</strong></h3>
<ul>
<li>
<p><strong>对象</strong>是属性的容器，用于存储数据和定义行为。</p>
</li>
<li>
<p><strong>属性</strong>是对象的组成部分，用于描述对象的状态和行为。</p>
</li>
<li>
<p>对象与属性的关系是紧密的，属性属于对象，对象通过属性来存储和操作数据。</p>
</li>
</ul>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JS：数组方法列表]]></title>
    <link href="justbb.fun/17416119491548.html"/>
    <updated>2025-03-10T21:05:49+08:00</updated>
    <id>justbb.fun/17416119491548.html</id>
    <content type="html">
<![CDATA[<table>
<thead>
<tr>
<th>方法名</th>
<th>修改原数组</th>
<th>方法执行后返回值</th>
<th>函数功能</th>
<th>备注</th>
<th>文档链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>push</td>
<td>是</td>
<td>原数组length值</td>
<td>修改数组</td>
<td>添加数据到数组末尾</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push">链接</a></td>
</tr>
<tr>
<td>pop</td>
<td>是</td>
<td>被删除的元素</td>
<td>修改数组</td>
<td>删除数组末尾最后一个数据</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/pop">链接</a></td>
</tr>
<tr>
<td>shift</td>
<td>是</td>
<td>被删除的元素</td>
<td>修改数组</td>
<td>删除数组开头第一个元素</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/shift">链接</a></td>
</tr>
<tr>
<td>unshift</td>
<td>是</td>
<td>原数组的length值</td>
<td>修改数组</td>
<td>给数组开头添加数据</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift">链接</a></td>
</tr>
<tr>
<td>splice</td>
<td>是</td>
<td>被删除的数据组成的一个新数组</td>
<td>修改数组</td>
<td>删除或添加数据到数组中</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/splice">链接</a></td>
</tr>
<tr>
<td>slice</td>
<td>否</td>
<td>新数组</td>
<td>获取数组中部分数据</td>
<td>赋值数组中的数据</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice">链接</a></td>
</tr>
<tr>
<td>*forEach</td>
<td>否</td>
<td>无</td>
<td>处理数据</td>
<td>遍历，无返回值（undefined）</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">链接</a></td>
</tr>
<tr>
<td>*map</td>
<td>否</td>
<td>新数组</td>
<td>处理数据</td>
<td>遍历，返回新数组</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map">链接</a></td>
</tr>
<tr>
<td>*some</td>
<td>否</td>
<td>布尔值</td>
<td>判断</td>
<td>只要有检测函数返回真值，返回true</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some">链接</a></td>
</tr>
<tr>
<td>*filter</td>
<td>否</td>
<td>新数组</td>
<td>获取数组中部分数据</td>
<td>返回符合检测函数的数据组成的新数组</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">链接</a></td>
</tr>
<tr>
<td>*every</td>
<td>否</td>
<td>布尔值</td>
<td>判断</td>
<td>所有数据的检测函数都返回真值，返回true</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every">链接</a></td>
</tr>
<tr>
<td>*reduce</td>
<td>否</td>
<td>累加器中的数据</td>
<td>数据处理并加总</td>
<td>返回累加器中的数据</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">链接</a></td>
</tr>
<tr>
<td>*reduceRight</td>
<td>否</td>
<td>累加器中的数据</td>
<td>数据处理并加总</td>
<td>返回累加器中的数据</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">链接</a></td>
</tr>
<tr>
<td>*sort</td>
<td>是</td>
<td>原数组</td>
<td>排序</td>
<td>排序专用</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort">链接</a></td>
</tr>
<tr>
<td>reverse</td>
<td>是</td>
<td>原数组</td>
<td>排序</td>
<td>反向排序</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse">链接</a></td>
</tr>
<tr>
<td>*findIndex</td>
<td>否</td>
<td>索引值</td>
<td>找索引</td>
<td>检测函数返回true，那么返回该数据的索引值</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex">链接</a></td>
</tr>
<tr>
<td>indexOf</td>
<td>否</td>
<td>索引值</td>
<td>找索引</td>
<td>返回第一个匹配数据的索引值（从左向右查）</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf">链接</a></td>
</tr>
<tr>
<td>lastIndexOf</td>
<td>否</td>
<td>索引值</td>
<td>找索引</td>
<td>返回最后一个匹配数据的索引值（从右往左查）</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf">链接</a></td>
</tr>
<tr>
<td>*find</td>
<td>否</td>
<td>元素</td>
<td>找元素</td>
<td>返回检测函数返回真值的数据</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/find">链接</a></td>
</tr>
<tr>
<td>includes</td>
<td>否</td>
<td>布尔值</td>
<td>判断</td>
<td>如果传入的数据在数组中有，就返回true</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes">链接</a></td>
</tr>
<tr>
<td>concat</td>
<td>否</td>
<td>新数组</td>
<td>合并数组</td>
<td>原数组合并传入的数据（任何数据）到一个新数组</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat">链接</a></td>
</tr>
<tr>
<td>fill</td>
<td>是</td>
<td>原数组</td>
<td>修改数组</td>
<td>用某个数据覆盖填充数组中的数据</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill">链接</a></td>
</tr>
<tr>
<td>copyWithin</td>
<td>是</td>
<td>原数组</td>
<td>修改数组</td>
<td>用数组中的部分数据覆盖原数组中的指定索引位数据</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/copuWithin">链接</a></td>
</tr>
<tr>
<td>join</td>
<td>否</td>
<td>字符串</td>
<td>转字符串</td>
<td>链接所有数据为字符串</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/join">链接</a></td>
</tr>
<tr>
<td>keys</td>
<td>否</td>
<td>可迭代对象</td>
<td>产生可迭代对象</td>
<td>键值，就是属性名（都是数字）</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/keys">链接</a></td>
</tr>
<tr>
<td>values</td>
<td>否</td>
<td>可迭代对象</td>
<td>产生可迭代对象</td>
<td>值，数组中的数据</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/values">链接</a></td>
</tr>
<tr>
<td>entries</td>
<td>否</td>
<td>可迭代对象</td>
<td>产生可迭代对象</td>
<td>键值对，数组的形式，前面是属性名，后面是值</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/entries">链接</a></td>
</tr>
</tbody>
</table>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[孩子叛逆怎么办]]></title>
    <link href="justbb.fun/17414456449769.html"/>
    <updated>2025-03-08T22:54:04+08:00</updated>
    <id>justbb.fun/17414456449769.html</id>
    <content type="html">
<![CDATA[<p>听曹操来了讲<a href="https://www.douyin.com/video/6953830580454853895">带娃</a>，他是一个在中国生活了二十多年的老外，对中美文化都很了解，看他视频也感觉他活得很通透，对很多现象都有自己的理解。</p>
<p>他女儿最近想穿舌钉，作为爸爸肯定觉得这种有点危险，觉得女儿考虑的不全面，真穿了多半会后悔。<br />
但14岁的叛逆期的孩子，直接说肯定不会听你的，作为家长有什么办法吗？</p>
<p>曹操给的建议就是拖一下，她让孩子认真考虑一个月，一个月后如果还想打，就带她打。</p>
<p>这段时间，可以让她好好冷静一下，她可能会去找一些打舌钉的好与坏，然后就渐渐对它失去兴趣了。</p>
<p>但最大概率其实是，她可能忘了。</p>
<p>所以这个问题就解决了。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JS：常见隐式类型转换]]></title>
    <link href="justbb.fun/17426435059284.html"/>
    <updated>2025-03-22T19:38:25+08:00</updated>
    <id>justbb.fun/17426435059284.html</id>
    <content type="html">
<![CDATA[<p>在 JavaScript 中，<strong>隐式类型转换</strong>（也称为类型强制转换）是语言的一个重要特性。当操作符两边的数据类型不一致时，JavaScript 会尝试自动将数据转换为合适的类型以完成操作。以下是你提到的常见隐式类型转换规则的详细解释和补充：</p>
<hr />
<h3><a id="1%C2%A0%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. <strong>数字类型转换</strong></h3>
<p>当任何其他类型的数据与数字类型进行比较或运算时，JavaScript 会尝试将其转换为数字。</p>
<h4><a id="%E8%A7%84%E5%88%99%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>规则：</h4>
<ul>
<li>
<p><code>null</code> 转换为数字是 <code>0</code>。</p>
</li>
<li>
<p>空字符串 <code>&quot;&quot;</code> 转换为数字是 <code>0</code>。</p>
</li>
<li>
<p><code>false</code> 转换为数字是 <code>0</code>。</p>
</li>
<li>
<p><code>true</code> 转换为数字是 <code>1</code>。</p>
</li>
<li>
<p><code>undefined</code> 转换为数字是 <code>NaN</code>。</p>
</li>
<li>
<p>字符串内容为数字（如 <code>&quot;123&quot;</code>）会转换为对应的数字（如 <code>123</code>）。</p>
</li>
<li>
<p>字符串内容为非数字（如 <code>&quot;abc&quot;</code>）会转换为 <code>NaN</code>。</p>
</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">console.log(null == 0);       // false（注意：null 只与 undefined 相等）
console.log(+null);           // 0
console.log(+&quot;&quot;)              // 0
console.log(+false);          // 0
console.log(+true);           // 1
console.log(+undefined);      // NaN
console.log(+&quot;123&quot;);          // 123
console.log(+&quot;abc&quot;);          // NaN
</code></pre>
<hr />
<h3><a id="2%C2%A0%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. <strong>布尔类型转换</strong></h3>
<p>当数据需要被转换为布尔值时，JavaScript 会根据以下规则进行转换。</p>
<h4><a id="%E8%A7%84%E5%88%99%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>规则：</h4>
<ul>
<li>
<p><code>false</code>、<code>0</code>、<code>&quot;&quot;</code>（空字符串）、<code>null</code>、<code>undefined</code>、<code>NaN</code> 转换为布尔值是 <code>false</code>。</p>
</li>
<li>
<p>其他所有值（包括对象、非空字符串、非零数字等）转换为布尔值是 <code>true</code>。</p>
</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">console.log(Boolean(null));      // false
console.log(Boolean(&quot;&quot;));        // false
console.log(Boolean(0));         // false
console.log(Boolean(undefined)); // false
console.log(Boolean(NaN));       // false
console.log(Boolean(&quot; &quot;));       // true（空格是非空字符串）
console.log(Boolean({}));        // true（对象）
console.log(Boolean([]));        // true（数组）
console.log(Boolean(123));       // true
console.log(Boolean(&quot;abc&quot;));     // true
</code></pre>
<hr />
<h3><a id="3%C2%A0-nan%E7%9A%84%E7%89%B9%E6%AE%8A%E8%A1%8C%E4%B8%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. <strong>NaN 的特殊行为</strong></h3>
<p><code>NaN</code> 是一个特殊的数值，表示“不是一个数字”。它与任何值（包括它自己）比较都会返回 <code>false</code>。</p>
<h4><a id="%E8%A7%84%E5%88%99%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>规则：</h4>
<ul>
<li>
<p><code>NaN</code> 与任何数据比较都是 <code>false</code>，包括 <code>NaN == NaN</code>。</p>
</li>
<li>
<p>使用 <code>isNaN()</code> 或 <code>Number.isNaN()</code> 可以检测一个值是否为 <code>NaN</code>。</p>
</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">console.log(NaN == NaN);      // false
console.log(NaN === NaN);     // false
console.log(isNaN(NaN));      // true
console.log(Number.isNaN(NaN)); // true
</code></pre>
<hr />
<h3><a id="4%C2%A0%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. <strong>对象类型的隐式转换</strong></h3>
<p>当对象参与运算或比较时，JavaScript 会尝试调用对象的 <code>valueOf()</code> 或 <code>toString()</code> 方法将其转换为原始值。</p>
<h4><a id="%E8%A7%84%E5%88%99%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>规则：</h4>
<ul>
<li>
<p>如果对象有 <code>valueOf()</code> 方法，优先调用 <code>valueOf()</code>。</p>
</li>
<li>
<p>如果没有 <code>valueOf()</code> 或 <code>valueOf()</code> 返回的不是原始值，则调用 <code>toString()</code>。</p>
</li>
<li>
<p>如果 <code>toString()</code> 也不存在或返回的不是原始值，则抛出错误。</p>
</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">let obj = {
    valueOf() {
        return 100;
    },
    toString() {
        return &quot;200&quot;;
    }
};

console.log(obj + 1); // 101（调用 valueOf）
console.log(String(obj)); // &quot;200&quot;（调用 toString）

</code></pre>
<hr />
<h3><a id="5%C2%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5. <strong>字符串拼接的隐式转换</strong></h3>
<p>当使用 <code>+</code> 操作符时，如果其中一个操作数是字符串，JavaScript 会将另一个操作数隐式转换为字符串。</p>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<p><code>javascript console.log(1 + &quot;2&quot;);       // &quot;12&quot;（数字 1 被转换为字符串） console.log(true + &quot;abc&quot;);  // &quot;trueabc&quot;（布尔值 true 被转换为字符串）</code></p>
<hr />
<h3><a id="6%C2%A0%E5%92%8C%E7%9A%84%E5%8C%BA%E5%88%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>6. <strong>== 和 === 的区别</strong></h3>
<ul>
<li>
<p><code>==</code> 会进行隐式类型转换后再比较。</p>
</li>
<li>
<p><code>===</code> 不会进行类型转换，直接比较值和类型。</p>
</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">console.log(1 == &quot;1&quot;);      // true（字符串 &quot;1&quot; 被转换为数字 1）
console.log(1 === &quot;1&quot;);     // false（类型不同）
console.log(null == undefined); // true（特殊规则）
console.log(null === undefined); // false（类型不同）
</code></pre>
<hr />
<h3><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h3>
<p>隐式类型转换是 JavaScript 中一个强大但容易出错的功能。理解这些规则可以帮助你更好地调试代码和避免潜在的错误。以下是一些关键点：</p>
<ul>
<li>
<p>数字转换：<code>null</code> → <code>0</code>，<code>&quot;&quot;</code> → <code>0</code>，<code>false</code> → <code>0</code>，<code>true</code> → <code>1</code>，<code>undefined</code> → <code>NaN</code>。</p>
</li>
<li>
<p>布尔转换：<code>false</code>、<code>0</code>、<code>&quot;&quot;</code>、<code>null</code>、<code>undefined</code>、<code>NaN</code> → <code>false</code>，其他 → <code>true</code>。</p>
</li>
<li>
<p><code>NaN</code> 与任何值比较都是 <code>false</code>。</p>
</li>
<li>
<p>对象会尝试调用 <code>valueOf()</code> 或 <code>toString()</code> 进行转换。</p>
</li>
</ul>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[试着用 AI 写 word 脚本]]></title>
    <link href="justbb.fun/17412722521826.html"/>
    <updated>2025-03-06T22:44:12+08:00</updated>
    <id>justbb.fun/17412722521826.html</id>
    <content type="html">
<![CDATA[<p>最近总是有很多合同要处理，但其实合同模板都是一样的，只是里面的甲方对象不同，所以突然想到word其实有vba宏可以使用。<br />
所以让AI帮我写了个脚本，自己稍加改动就可以运行。<br />
目前就是界面还不太友好，全是弹窗，下一步试试改下界面。</p>
<pre><code class="language-plain_text">Sub GenerateContract()
    ' 声明变量
    Dim doc As Document
    Dim partyA As String    ' 甲方名称
    Dim partyAAddress As String    ' 甲方地址
    Dim partyAContact As String    ' 甲方联系人
    Dim contractDate As String     ' 合同日期
    Dim contractNo As String       ' 合同编号
    
    ' 获取用户信息（这里可以通过输入框或指定单元格获取）
    partyA = InputBox(&quot;请输入甲方名称：&quot;)
    partyAAddress = InputBox(&quot;请输入甲方地址：&quot;)
    partyAContact = InputBox(&quot;请输入甲方联系人：&quot;)
    contractDate = Format(Date, &quot;yyyy年mm月dd日&quot;)
    contractNo = &quot;FG&quot; &amp; Format(Date, &quot;yyyymmdd&quot;) &amp; &quot;-&quot; &amp; Format(Time, &quot;hhmm&quot;)
    
    ' 打开模板文档
    Set doc = Documents.Open(&quot;/Users/lay/Dropbox/客户QA/合同模板/ContractTemplate.doc&quot;) ' 修改为你的模板路径
    
    ' 替换模板中的占位符
    With doc
        ' 假设模板中使用 {PartyA} 这样的占位符
        .Application.Selection.Find.Execute FindText:=&quot;{PartyA}&quot;, _
            replaceWith:=partyA, Replace:=wdReplaceAll
        .Application.Selection.Find.Execute FindText:=&quot;{PartyAAddress}&quot;, _
            replaceWith:=partyAAddress, Replace:=wdReplaceAll
        .Application.Selection.Find.Execute FindText:=&quot;{PartyAContact}&quot;, _
            replaceWith:=partyAContact, Replace:=wdReplaceAll
        .Application.Selection.Find.Execute FindText:=&quot;{ContractDate}&quot;, _
            replaceWith:=contractDate, Replace:=wdReplaceAll
        .Application.Selection.Find.Execute FindText:=&quot;{ContractNo}&quot;, _
            replaceWith:=contractNo, Replace:=wdReplaceAll
    End With
    
    ' 另存为新文档
    doc.SaveAs2 FileName:=&quot;/Users/lay/Dropbox/客户QA/合同模板/&quot; &amp; PartyA &amp; &quot;飞鸽劳务通SaaS软件系统及抖音招聘账号报白使用权益服务合同_&quot; &amp; contractNo &amp; &quot;.doc&quot;
    
    ' 可选择是否关闭文档
    ' doc.Close
    
    MsgBox &quot;合同已生成！保存路径：/Users/lay/Dropbox/客户QA/合同模板/合同_&quot; &amp; contractNo &amp; &quot;.doc&quot;
    
    ' 清理
    Set doc = Nothing
End Sub

</code></pre>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从两岸报告看中国的经济股市与美元的汇率转折]]></title>
    <link href="justbb.fun/17419289426793.html"/>
    <updated>2025-03-14T13:09:02+08:00</updated>
    <id>justbb.fun/17419289426793.html</id>
    <content type="html">
<![CDATA[<p>WB会员文章：</p>
<p>近期太平洋两岸分别作了一年一度的政府报告，当然在美国那边叫作国情咨文。美国的国情咨文和中国的政府工作报告分属逻辑完全不同的政治传统，对于美国政治来说，国情咨文更重要的是动员、煽动、团结的作用，更像一场show，是在直接选举体制下的一种更具仪式性的行为。中国的政府工作报告则更像是理性计划时代的延续，没有那么多表演成分，重点都是实实在在的数字KPI。但由于现代经济的复杂性和多变性，政府工作报告对于政策取向的表述更多只是反应当下时点的。现代社会治理经济最长也要按月思考决策，用飞行员开飞机来比喻再合适不过，尤其是遇到关键的节点，几个月没开好就有撞机和偏航的风险。</p>
<p>今年中国政府工作报告整体上中规中矩，既没有超预期也没有不及预期，延续了去年9月份以来的基调。同时由于去年9月份开始经济整体向好的势头愈发明显，本次报告也没有再给更进一步超预期的信号。最能说明的就是赤字率安排在4%，其实这个赤字率没什么用，因为政府债务的真实赤字远大于每年公告的这个数，报告中提到的这个数一般被称为“狭义赤字”。狭义赤字的信号意义大于实际意义，今年的4%是自08年以来最高的一次赤字率，但同时也并没有达到去年一些学者公开建议的5%水平，体现了一种保持积极基调下的折中态度，也为后续需要更大刺激留了后手。</p>
<p>如果我们将更接近真实赤字水平的超长期特别国债、专项债、特别国债这三个也考虑进赤字后，那么赤字率的可比水平将从2024年的6.6%增加到2025年的8.4%，这个增加力度也是不小的。针对市场上近期流传的一些由于经济回暖政府刺激政策有阶段性收缩的观点，我觉得可能有一些体现这个思路的货币政策操作，但这并不改变目前整体上仍然以超常规逆周期调节为方向的总基调。</p>
<p>关于股市层面，本次报告有提到“加强战略性力量储备和稳市机制建设”，这个被市场理解为有可能进一步加强中长期资金入市和平准基金类资金入市的政策。但这方面我们之前的文章分析的一个基本思路是，除非平准基金和可动用的中长期资金体量足够大，否则很难对股市产生根本性影响，而目前的国内可动用资金体量相较于A股庞大的流通市值可以说是杯水车薪，所以救市资金更重要的是发挥股灾兜底，而非牛市催生的作用。</p>
<p>但从2月份以来，股市的变化，尤其是港股的变化出现了一些积极的信号。这轮的港股上涨带有“讲故事氛围”的巨大变化。除了和AI概念沾边的科技股行情，还有一些其他的现象——如B站在发布了一份和上季度基本面差不多的财报后股价波动出现了巨大差别，特朗普加征关税的心理影响也没有阻挡港股上涨的大趋势等等。本轮上涨能否真正带动一次港股牛市越来越值得期待。当然，跟我们分析时间比较长的听友应该知道我核心的观点仍然，港股的上涨最根本的原因是估值足够低，跌的足够久。在这种情况下，任何概念和叙事氛围的变化最后都可能催生一波真正的牛市，即使现在没有DeepSeek大家最终也会找到其他的理由。同理，美股的下跌也是早晚会出现的事，巴菲特并不知道中国今年会有DeepSeek，但他仍然在1年前就开始大幅减持美股。</p>
<p>除了宏观政策与股市以外，我在去年9月新政之后持续关注了北京二手房成交情况，到目前为止数据一直保持在比较好的状态。同时我们看到以10年期国债为代表的长期市场利率自2月份以来也出现了明显的触底反弹。这些信号都在预示，中国本轮自2023年下半年开始的流动性陷阱有可能逐步的出现转折。当然，预测宏观经济本身就是很困难的事，未来是否还会遇到其他不确定性的事件我们无法预测。唯一能让我们保持长期盈利的方式只有在低估值阶段建仓。</p>
<p>另一方面，美国目前的经济形势普遍被市场认为可能面临从增长到滞胀的转折。从正常的短经济周期来说，美国这一轮的上行周期已经持续了很久，即使没有其他干扰因素，阶段性衰退的可能性也已经越来越大。同时由于美股出现了极端高估的情况，如果后续的阶段性衰退跌加了美国崩盘，那么财富缩水的效应会进一步给美国经济带来打击。而通胀的延续主要是由于特朗普关税政策的影响。</p>
<p>关于美股的高估问题我们已经在12月份的时候写过文章《美股的高估与范式转移风险》。而关税问题我们一直以来都持有一个判断，即特朗普并非单纯的以提高关税为目标，其最终目标应是减少美国的货物贸易逆差以及增加美国本土FDI投资。达成这个目标既可以靠关税，也可以靠美元汇率贬值，故其最终有可能以关税作为谈判筹码，最终通过汇率与关税的组合方式实现其目标，关于这方面的原理，我们在会员文章《关于特朗普“对华50%关税”政策的理解》（2024-7-18）也有过详细的阐述，感兴趣的朋友可以参考。</p>
<p>当下的形势来看，汇率变化更有可能是达成各方平衡的首选。首先，中国国内的宏观经济回暖和市场利率的上行本身就会改变外汇投机市场的预期，造成人民币升值。同时二级市场资产重估的股市也会带动国际热钱兑换人民币，进一步加强人民币的升值趋势（同时也对应美元被卖出的趋势）。而在美国方面，利用美元贬值实现贸易目标，可以减少最终的实际关税加征，也可以减少国内通胀的预期，所以当下的逻辑有可能是国内通胀数据越高，特朗普加征关税政策的阻力就会越大，从而导致特朗普更倾向于使用汇率工具实现目标，这也可能是近期美元汇率波动一反之前的通胀上行——加息预期——美元升值的传导逻辑，而出现了通胀上行——美元贬值的市场现象。特朗普从关税到汇率的政策工具变化，本质上就是将美国的国内通胀转嫁为国际市场上的美元贬值。</p>
<p>总结来说，如果目前中国经济回暖和二级市场上涨的趋势得到确立，且美国的通胀趋势不减的话，那么人民币和美元的汇率转折风险将会越来越大。当中国走出流动性陷阱的时候，美国要么选择滞胀，要么选择美元贬值。而这个选择题对于任何一位脑子不傻的美国领导人来说都是极为简单的，更何况是特朗普。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为什么中国C端大厂，产品名都挺低龄]]></title>
    <link href="justbb.fun/17412489236160.html"/>
    <updated>2025-03-06T16:15:23+08:00</updated>
    <id>justbb.fun/17412489236160.html</id>
    <content type="html">
<![CDATA[<blockquote><p lang="zh" dir="ltr">全中国的互联网产品命名法。主要是面对C端的。名字和logo都非常接地气。菜鸟，咸鱼，XX宝，天猫。其实是普通消费者教育程度和想象力还是不高。必须贴地飞行才能深入人心。 就连领导讲话也是一样。 <a href="https://t.co/rF7Sqs6ELr">https://t.co/rF7Sqs6ELr</a></p>&mdash; David Chang (@David_yc607) <a href="https://twitter.com/David_yc607/status/1897509483406147671?ref_src=twsrc%5Etfw">March 6, 2025</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>最近看到大卫分享了一个国内产品起名的背景，挺有意思的。其实不光是产品名称，很多时候国内的产品形象，也有大量低幼设计元素，比如派出所的一些宣传海报，人物均是卡通式的警察。</p>
<p>但也要知道事物都是在发展的，这种「低幼化」的设计，总好过直接的白底黑字那种，一点都不「亲民」的设计。未来这些设计肯定会随着人群认知，逐渐发生变化的。</p>
]]>
    </content>
  </entry>
  
</feed>
