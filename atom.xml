<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[JustBB]]></title>
  <link href="justbb.fun/atom.xml" rel="self"/>
  <link href="justbb.fun/"/>
  <updated>2025-03-16T12:20:51+08:00</updated>
  <id>justbb.fun/</id>
  <author>
    <name><![CDATA[]]></name>
  </author>
  
  <entry>
    <title type="html"><![CDATA[原型（Prototype）和原型链（Prototype Chain）]]></title>
    <link href="justbb.fun/17420542537025.html"/>
    <updated>2025-03-15T23:57:33+08:00</updated>
    <id>justbb.fun/17420542537025.html</id>
    <content type="html">
<![CDATA[<p><strong>原型（Prototype）</strong> 和 <strong>原型链（Prototype Chain）</strong> 是 JavaScript 中实现继承和共享属性的核心机制。<br />
理解 <code>[[Prototype]]</code>、<code>prototype</code> 和 <code>constructor</code> 的关系，是掌握 JavaScript 面向对象编程的关键。</p>
<hr />
<h3><a id="1%C2%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%C2%A0-prototype%C2%A0%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. <strong>对象的 <code>[[Prototype]]</code> 属性</strong></h3>
<ul>
<li>每个对象（对象实例）都有一个内部属性 <code>[[Prototype]]</code>，默认指向一个对象。</li>
<li>这个对象（称为原型对象），它包含可以由该函数创建的所有实例共享的属性和方法。</li>
<li>这个 <code>[[Prototype]]</code> 属性可以通过 <code>Object.getPrototypeOf(obj)</code> 或 <code>obj.__proto__</code> 访问。</li>
<li>如果对象是通过字面量创建的，<code>[[Prototype]]</code> 默认指向 <code>Object.prototype</code>。</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">const obj = {};
console.log(Object.getPrototypeOf(obj) === Object.prototype); // 输出: true
console.log(obj.__proto__ === Object.prototype); // 输出: true
</code></pre>
<hr />
<h3><a id="2%C2%A0-new%C2%A0%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. <strong><code>new</code> 关键字和构造函数</strong></h3>
<ul>
<li>
<p>当使用 <code>new</code> 关键字调用构造函数时，会创建一个新的对象。</p>
</li>
<li>
<p>这个新对象的 <code>[[Prototype]]</code> 属性会被设置为构造函数的 <code>prototype</code> 属性指向的对象。</p>
</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">function Person(name) {
  this.name = name;
}

const alice = new Person('Alice');
console.log(Object.getPrototypeOf(alice) === Person.prototype); // 输出: true
console.log(alice.__proto__ === Person.prototype); // 输出: true
</code></pre>
<ul>
<li>
<p><strong>解释</strong>：</p>
<ul>
<li>
<p><code>alice</code> 是通过 <code>new Person()</code> 创建的对象。</p>
</li>
<li>
<p><code>alice</code> 的 <code>[[Prototype]]</code> 属性指向 <code>Person.prototype</code>。</p>
</li>
</ul>
</li>
</ul>
<hr />
<h3><a id="3%C2%A0%E5%87%BD%E6%95%B0%E7%9A%84%C2%A0-prototype%C2%A0%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. <strong>函数的 <code>prototype</code> 属性</strong></h3>
<ul>
<li>
<p>每个函数都有一个 <code>prototype</code> 属性，这个属性是一个对象。</p>
</li>
<li>
<p>这个 <code>prototype</code> 对象有一个 <code>constructor</code> 属性，指向函数本身。</p>
</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">function Person(name) {
  this.name = name;
}

console.log(Person.prototype.constructor === Person); // 输出: true
</code></pre>
<ul>
<li>
<p><strong>解释</strong>：</p>
<ul>
<li><code>Person.prototype</code> 是一个对象，它的 <code>constructor</code> 属性指向 <code>Person</code> 函数本身。</li>
</ul>
</li>
</ul>
<hr />
<h3><a id="4%C2%A0%E5%8E%9F%E5%9E%8B%E9%93%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. <strong>原型链</strong></h3>
<ul>
<li>当访问对象的属性或方法时，如果对象本身没有该属性或方法，JavaScript 会沿着 <code>[[Prototype]]</code> 链向上查找，直到找到该属性或方法，或者到达原型链的尽头（<code>null</code>）。</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">function Person(name) {
  this.name = name;
}

// 在 Person.prototype 上添加方法
Person.prototype.sayHello = function() {
  console.log(`Hello, my name is ${this.name}`);
};

const alice = new Person('Alice');
alice.sayHello(); // 输出: Hello, my name is Alice
</code></pre>
<ul>
<li>
<p><strong>解释</strong>：</p>
<ul>
<li>
<p><code>alice</code> 本身没有 <code>sayHello</code> 方法，但它的 <code>[[Prototype]]</code> 指向 <code>Person.prototype</code>，而 <code>Person.prototype</code> 上有 <code>sayHello</code> 方法。</p>
</li>
<li>
<p>因此，<code>alice</code> 可以调用 <code>sayHello</code> 方法。</p>
</li>
</ul>
</li>
</ul>
<hr />
<h3><a id="5%C2%A0%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E5%B0%BD%E5%A4%B4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5. <strong>原型链的尽头</strong></h3>
<ul>
<li>
<p>原型链的尽头是 <code>null</code>。</p>
</li>
<li>
<p><code>Object.prototype</code> 是大多数对象的原型链的终点，它的 <code>[[Prototype]]</code> 是 <code>null</code>。</p>
</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">console.log(Object.getPrototypeOf(Object.prototype)); // 输出: null
</code></pre>
<hr />
<h3><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h3>
<ol>
<li>
<p><strong><code>[[Prototype]]</code></strong>：</p>
<ul>
<li>
<p>每个对象都有一个 <code>[[Prototype]]</code> 属性，指向它的原型对象。</p>
</li>
<li>
<p>默认情况下，对象的 <code>[[Prototype]]</code> 指向 <code>Object.prototype</code>。</p>
</li>
</ul>
</li>
<li>
<p><strong><code>new</code> 关键字</strong>：</p>
<ul>
<li>使用 <code>new</code> 关键字调用构造函数时，新对象的 <code>[[Prototype]]</code> 会被设置为构造函数的 <code>prototype</code> 属性指向的对象。</li>
</ul>
</li>
<li>
<p><strong>函数的 <code>prototype</code> 属性</strong>：</p>
<ul>
<li>
<p>每个函数都有一个 <code>prototype</code> 属性，指向一个对象。</p>
</li>
<li>
<p>这个对象的 <code>constructor</code> 属性指向函数本身。</p>
</li>
</ul>
</li>
<li>
<p><strong>原型链</strong>：</p>
<ul>
<li>当访问对象的属性或方法时，JavaScript 会沿着 <code>[[Prototype]]</code> 链向上查找，直到找到该属性或方法，或者到达 <code>null</code>。</li>
</ul>
</li>
</ol>
<hr />
<h3><a id="%E5%9B%BE%E7%A4%BA%E5%8E%9F%E5%9E%8B%E9%93%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>图示原型链</h3>
<p>以下是一个简单的原型链图示：</p>
<pre><code class="language-plain_text">alice (实例对象)
  |
  | [[Prototype]]
  v
Person.prototype
  |
  | [[Prototype]]
  v
Object.prototype
  |
  | [[Prototype]]
  v
null
</code></pre>
<ul>
<li>
<p><code>alice</code> 是 <code>Person</code> 的实例，它的 <code>[[Prototype]]</code> 指向 <code>Person.prototype</code>。</p>
</li>
<li>
<p><code>Person.prototype</code> 的 <code>[[Prototype]]</code> 指向 <code>Object.prototype</code>。</p>
</li>
<li>
<p><code>Object.prototype</code> 的 <code>[[Prototype]]</code> 指向 <code>null</code>。</p>
</li>
</ul>
<hr />
<h3><a id="%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例代码</h3>
<p>以下是一个完整的示例，展示原型链的工作原理：</p>
<pre><code class="language-javascript">function Person(name) {
  this.name = name;
}

// 在 Person.prototype 上添加方法
Person.prototype.sayHello = function() {
  console.log(`Hello, my name is ${this.name}`);
};

const alice = new Person('Alice');

// 访问属性和方法
console.log(alice.name); // 输出: Alice
alice.sayHello(); // 输出: Hello, my name is Alice

// 检查原型链
console.log(Object.getPrototypeOf(alice) === Person.prototype); // 输出: true
console.log(Object.getPrototypeOf(Person.prototype) === Object.prototype); // 输出: true
console.log(Object.getPrototypeOf(Object.prototype) === null); // 输出: true

</code></pre>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[练习：数组综合]]></title>
    <link href="justbb.fun/17419571663740.html"/>
    <updated>2025-03-14T20:59:26+08:00</updated>
    <id>justbb.fun/17419571663740.html</id>
    <content type="html">
<![CDATA[<pre><code class="language-javascript">/* 
练习1:
定义一个构造函数 一个参数
使用该构造函数 配合new 会产生有一个属性age的实例对象
let arr = [12,41,20,66,35,70]
利用上面数组中的数据，产出一个新组
数组中都是该构造函数的实例，实例的age值依次分别数arr这个数组中的数据
同时 最终的数组中的对象顺序 要按照age属性的值从小到大排列 */&lt;!----&gt;

let arr1 = [12,41,20,66,35,70]

function PersonAge(age) {
    this.age = age
}
/*
//方法一
let newArr = []
 
arr1.forEach((ele)=&gt;{
    newArr.push(new PersonAge(ele))
})

newArr.sort((a,b)=&gt;a.age-b.age) */

//方法二
const newArr = arr1.map((ele)=&gt; new PersonAge(ele)).sort((a,b)=&gt;a.age-b.age)

console.log(newArr);

</code></pre>
<pre><code class="language-javascript">/* 
练习2:
定义一个函数，函数有两个参数，参数传入有数据的数组
会比较这传入的两个数组中是否有相同（严格相等）的数据有 函数返回true
没有 返回false

*/
const arra = ['tom'];
const arrb = ['a', 'b', 'c', 1, 2, 3, 4];

function testArr(arr1, arr2) {
  const result = arr1.findIndex((ele1) =&gt; {
    // 检查 ele1 是否在 arr2 中
    return arr2.includes(ele1);
  });

  console.log(result); // 输出找到的索引，未找到则为 -1

  if (result !== -1) {
    console.log(true);
  } else {
    console.log(false);
  }
}

testArr(arra, arrb); // 输出: -1, false

-------

arra = [1,'tom']
arrb = ['a','b','c',1,2,3,4]

function testArr(arr1,arr2) {
    const result = arr1.findIndex((ele1,index1,array1) =&gt; {
        const result2 = arr2.findIndex((ele2,index2,array2) =&gt; {
        return ele2 === ele1
    })

        if (result2 !== -1) {
            return true
        }else{
            return false
        }

    })
    
    if (result !== -1) {
        return true
    }else{
        return false
    }
 
}

console.log(testArr(arra,arrb));

---------

arra = [0,'tom',2]
arrb = ['a','b','c',1,2,3,4]

function testArr(arr1,arr2) {
    const result = arr1.findIndex(
        (ele)=&gt;{
            return arr2.includes(ele)
        }
    )
    console.log(result);
    
    if (result !== -1) {
        console.log(true);
    }else{
        console.log(false);
    }
    
 
}

console.log(testArr(arra,arrb));

---------
// 最合理的方案
const arra = [0, 'tom', 2];
const arrb = ['a', 'b', 'c', 1, 2, 3, 4];

function testArr(arr1, arr2) {
  const result = arr1.some((ele) =&gt; arr2.includes(ele)); // 检查是否存在匹配元素
  console.log(result); // 直接输出 true 或 false
}

testArr(arra, arrb); // 输出: true

</code></pre>
<pre><code class="language-javascript">let arr = [
    {name:'小明',score:60},
    {name:'小花',score:81},
    {name:'小亮',score:62},
    {name:'小章',score:73},
    {name:'小李',score:66},
    {name:'小胖',score:92},
]
// 练习3:
// 定义一个函数 可以传入一个数组 和 一个字符串这个函数执行时 可以筛选出数组中分数低于80分的对象 然后给该对象 设置一个属性 叫做 label 这个属性的值就是传入的第二个参数 字符串
// 同时 要创建一个新的数组 用深克隆的方式 按原数组相反的顺序 复制这些对象数据到新的的数组中
// 最后 还要在这个新数组的最后加上一个 所有对象的score总分的数据 数字类型的数据
// 函数执行完之后把这个新数组返回

function testArr(arr,str) {
    const newArr = arr.filter((ele)=&gt;ele.score&lt;80
    )
    
    newArr.forEach(element =&gt; {
        element.lable = str
    });

    arr.reverse()
    

    const result = arr.map(ele=&gt;{
        return{
            ...ele
        }//创建了新对象，也就开辟了新的内存空间，与原对象不影响，创建的新对象会被添加到map方法执行后要返回的新对象中
    })

    return result

    arr[1].lable = '测试' //测试是否arr和resutl引用的是不是同一数据

    console.log(result);
    console.log(arr);
    
}
testArr(arr,'不太好')
// console.log(newArr);

</code></pre>
<pre><code class="language-javascript">// 练习 4
// 定义一个函数 传入两个参数，第一个是数组 第二个传某个数据
// 执行时传入上述这样结构的数组 和 一个你筛选的数据
// 筛选出数组中 和 传入进行筛选数据严格相等的数据
// 统计一共有多少个 返回 数量

let arr1 = [[1,2,3,'s','m','6',true],[1,1,32,'s2','木','6',false]]


function countArr(arr,data) {
    const  newArr = []
    arr.forEach(element =&gt; {
        element.forEach(ele=&gt;
            newArr.push(ele)
        );
        
    });
    console.log(newArr);
    let count = 0
    let idx = newArr.indexOf(data)
    while(idx!==-1) {
        idx = newArr.indexOf(data,idx+1)
        count++

    }
    console.log(count);

}

countArr(arr1,'6')

-------------

let arr1 = [
  [1, 2, 3, 's', 'm', '6', true],
  [1, 1, 32, 's2', '木', '6', false]
];

function countArr(arr, data) {
  // 使用 flat() 方法将二维数组扁平化
  const newArr = arr.flat();
  
  // 使用 filter() 方法统计 data 出现的次数
  const count = newArr.filter(item =&gt; item === data).length;
  
  console.log(`元素 &quot;``{data}&quot; 出现的次数为: ``{count}`);
}

countArr(arr1, '6'); // 输出: 元素 &quot;6&quot; 出现的次数为: 2

-------

let arr1 = [[1,2,3,'s','m','6',true],[1,1,32,'s2','木','6',false]]


function countArr(arr,data) {
    let  newArr = []
    arr.forEach(ele =&gt; {
        const tempArr = ele.filter(
            (item)=&gt;item === data
        )
        newArr = newArr.concat(tempArr)
    });
    
    console.log(newArr.length);
    
    
    
}

countArr(arr1,'6')

</code></pre>
<pre><code class="language-javascript">
// 练习5
// 根据这个数组 创建一个新数组
// 这个新数组 的每一位数据 都是这个原数组相应索引位的值 与下一位索引位的值的和
// 如果是最后一位 那就是和第一位的和

let arr1 = [1,2,3,4,5,6,7,8,9]

let arr2 = arr1.map((ele,index)=&gt;{
    if (index === arr1.length-1) {
        return arr1[index]+arr1[0]
    }else{
        return arr1[index+1]+ele
    }
    
})

console.log(arr2);

</code></pre>
<pre><code class="language-javascript">// 练习6
// 定义一个函数 一个参数
// 可以把传入的数组
// 按照不同的数据类型进行不同的处理
// 如果是数字类型 把所有数字类型相加
// 如果是字符串 所有字符串拼接到一起
// 其他类型都忽略
// 然后 加总的数字 和 拼接的字符串 添加到原数组的后面
// 返回原数组

let arr1 = [[1,2],1,2,3,'你好','笨蛋',{a:12},true]

function testArr(arr) {
    let temp1 =  arr1.filter((ele)=&gt;typeof ele === 'number')
    let temp2 =  arr1.filter((ele)=&gt;typeof ele === 'string')
    let result1 = temp1.reduce((a,b)=&gt;a+b)
    let result2 = temp2.join('')
    arr1.push(result1,result2)
    console.log(arr1);
    
}

testArr(arr1)
---------------
let arr1 = [[1,2],1,2,3,'你好','笨蛋',{a:12},true]

function testArr(arr) {
    let strTotal = ''
    let numTotal = 0
    arr.forEach((ele)=&gt;{
        if (typeof ele === 'string') {
            strTotal += ele
        }else if(typeof ele === 'number'){
            numTotal += ele
        }
    })

    arr.push(strTotal,numTotal)
    return arr
}


console.log(testArr(arr1));


</code></pre>
<pre><code class="language-javascript">// 练习7
// 定义一个函数 可以传入一个字符串
// 然后把字符串拆成一个个的字符
// 倒序放到一个数组中

let str = 'helloworld'

function strArr(str) {
    const arr = [...str]
    arr.reverse()
    console.log(arr);
    
}

strArr(str)


</code></pre>
<pre><code class="language-javascript">// 练习8
// 定义一个函数 两个参数 可以传入一个数组，和 一个数据类型的字符串 string number
// 函数执行时 如果 数组中有传入的数据类型
// 那么要把数组中所有数据全变成该类型的字符串名称
// 没有该类型数据的话
// 要把数组清空
// 最后返回这个原数组数组

let arr1 = [1,2,3,4,'3','23',true]

function testArr(arr,type) {
    const hasType = arr.some((ele)=&gt;typeof ele === type)
    if (hasType) {
        arr.fill(type)
    }else{
        arr.length = 0
    }
}

testArr(arr1,'object')
console.log(arr1);

</code></pre>
<pre><code class="language-javascript">
// 练习9
// 定义一个函数 传入两个参数 第一个数组 第二个是类型字符串
// 函数执行时 会把原数组中的所有非第二个参数类型名称的数据都删掉
// 这些删掉的数据会组成一个新数组
// 返回 新数组的长度

let arr = [1,'1',2,3,'s','m','6',true]

function handleArr(arr,typeStr) {
    
    let newArr = arr.map((ele,index)=&gt; {
        if (typeof ele === typeStr) {
            return index
        }
    }).filter(ele=&gt;ele !== undefined)
    
    arr = arr.filter(ele=&gt;typeof ele !== typeStr)

    console.log(newArr.length);
    console.log(arr);
    
    

}

handleArr(arr,'string')

-----------

// 练习9
// 定义一个函数 传入两个参数 第一个数组 第二个是类型字符串
// 函数执行时 会把原数组中的所有非第二个参数类型名称的数据都删掉
// 这些删掉的数据会组成一个新数组
// 返回 新数组的长度

let arr = [1,'1',2,3,'s','m','6',true]

function handleArr(arr,typeStr) {
    
    let newArr = arr.map((ele,index)=&gt; {
        if (typeof ele === typeStr) {
            return index
        }
    }).filter(ele=&gt;ele !== undefined)
    let spliceCount = 0
    // arr = arr.filter(ele=&gt;typeof ele !== typeStr)
    newArr.forEach(ele =&gt; {
        arr.splice(ele-spliceCount,1)
        spliceCount++;
    });

    console.log(newArr.length);
    console.log(arr); 

}

handleArr(arr,'string')
</code></pre>
<pre><code class="language-javascript">// 练习10
// 定义一个函数 可以传入这样一个数组
// 计算出这个数组中所有数字类型数据的总和的值
// 并把所有非数字类型的数据组成一个新数组
// 返回新数组

let arr = [1,[2,4],5,[6,'true',1],[6,10],true]

/* function numTotal(arr) {
    const newArr = arr.flat()
    console.log(newArr);

    const newArr2 = newArr.filter((ele)=&gt;typeof ele === 'number')
    const result = newArr2.reduce((a,b)=&gt;a+b)
    console.log(result);
}
 */

function numTotal(arr) {
    let total = 0
    let result =[]
    arr.forEach(ele =&gt; {
        if (typeof ele === 'number') {
            total += ele            
        }else if(ele instanceof Array){
            ele.forEach(ele1=&gt;{
                if (typeof ele1 === 'number') {
                    total += ele1
                }else{
                    result.push(ele1)
                }
            })
        }else{
            result.push(ele)
        }
    });

    console.log(total);
    console.log(result);
    
}

numTotal(arr)

</code></pre>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[成长股的卖出逻辑]]></title>
    <link href="justbb.fun/17419272058320.html"/>
    <updated>2025-03-14T12:40:05+08:00</updated>
    <id>justbb.fun/17419272058320.html</id>
    <content type="html">
<![CDATA[<p>成长股一般看动态市盈率。</p>
<h3><a id="1%E5%8A%A8%E6%80%81%E5%B8%82%E7%9B%88%E7%8E%87%E7%9A%84%E6%84%8F%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. 动态市盈率的意义</h3>
<p>动态市盈率是基于公司未来盈利预测计算的市盈率，反映了市场对公司未来增长的预期。对于成长股来说，动态市盈率是一个重要的估值指标，因为成长股的当前盈利可能较低，但未来盈利增长潜力较大。</p>
<p><strong>20-30倍动态市盈率：</strong> 这是一个常见的合理区间，尤其适用于高增长行业（如科技、医药等）。如果公司未来盈利增长能够支撑这一估值，那么股价仍有上涨空间。<br />
小于20倍：如果动态市盈率低于20倍，可能意味着市场低估了公司的成长潜力，或者公司增长放缓。你选择不卖出，是基于对公司未来增长的信心。</p>
<h3><a id="2%E5%8D%96%E5%87%BA%E6%97%B6%E6%9C%BA%E7%9A%84%E8%80%83%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. 卖出时机的考量</h3>
<p>你提到“除非有时候涨得太厉害”，这意味着你也会考虑股价的短期涨幅。以下是一些可能影响卖出决策的因素：</p>
<p>（1）估值过高</p>
<p>如果动态市盈率远高于30倍（例如超过50倍），可能意味着股价已经透支了未来几年的增长预期，存在回调风险。<br />
可以参考行业平均市盈率，如果远高于行业平均水平，可能需要谨慎。</p>
<p>（2）技术面超买<br />
如果股价短期内涨幅过大（例如超过50%或100%），可能会出现技术性回调。<br />
可以结合技术指标（如RSI、MACD）来判断是否超买。</p>
<p>（3）基本面变化<br />
如果公司的基本面发生变化（如业绩增速放缓、行业竞争加剧、管理层变动等），即使动态市盈率仍在合理区间，也可能需要考虑卖出。</p>
<p>目前持有快手-W，药明康德</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[小米电视设置ADB常用命令]]></title>
    <link href="justbb.fun/17420096800849.html"/>
    <updated>2025-03-15T11:34:40+08:00</updated>
    <id>justbb.fun/17420096800849.html</id>
    <content type="html">
<![CDATA[<p>通过 ADB 操作电视</p>
<pre><code class="language-python">adb connect 192.168.1.2
#查看自己电视IP并连接，注意在电视上点击确实

adb install D:\ATV.apk
#自行下载ATV Launcher Pro后，执行以上命令安装D:\ATV.apk到电视，并手动设置为系统桌面

adb shell pm uninstall -k --user 0 com.mitv.tvhome
#卸载小米桌面，如果想备份小米桌面App要自行下载安装Apk Extractor导出保存
</code></pre>
<p>一些或许会用到的ADB命令</p>
<pre><code class="language-python">adb shell pm list packages
#列出所有应用
 
adb shell pm list packages -s
#列出系统应用
 
adb shell pm list packages -3
#列出第三方应用
 
adb shell pm list packages -d
#列出已禁用应用
 
adb shell pm list packages -e
#列出已启用应用

adb shell dumpsys package com.mitv.tvhome
#查询应用详细信息

adb shell pm path com.mitv.tvhome
#查看应用安装路径

adb install D:\bilibili.apk
#安装D:\bilibili.apk到电视

adb install -s D:\bilibili.apk
#将应用安装到 SD 存储卡 

adb install -r D:\bilibili.apk
#允许覆盖安装
 
adb install -d D:\bilibili.apk
#允许降级覆盖安装
 
adb install -g D:\bilibili.apk
#允许应用所需全部权限

adb shell pm disable-user com.mitv.tvhome
#禁用某应用

adb shell pm enable com.mitv.tvhome
#恢复某应用

adb shell pm uninstall -k --user 0 com.mitv.tvhome
#卸载某应用

adb shell am force-stop com.mitv.tvhome
#强制停止某应用

adb push D:\bilibili.apk /sdcard/
#将D盘bilibili.apk文件传输到电视sdcard目录

adb pull /sdcard/bilibili.apk D:\Download
#将电视sdcard目录的bilibili.apk文件传输到电脑D:\Download

adb reboot
#重启系统

adb reboot recovery
#重启到 Recovery 模式

adb reboot bootloader
#重启到 Fastboot 模式 

</code></pre>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[函数是 JavaScript 中的一种特殊对象]]></title>
    <link href="justbb.fun/17420533060973.html"/>
    <updated>2025-03-15T23:41:46+08:00</updated>
    <id>justbb.fun/17420533060973.html</id>
    <content type="html">
<![CDATA[<h4><a id="1%C2%A0%E5%87%BD%E6%95%B0%E6%98%AF%C2%A0-function%C2%A0%E7%9A%84%E5%AE%9E%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. <strong>函数是 <code>Function</code> 的实例</strong></h4>
<ul>
<li>
<p>在 JavaScript 中，函数是通过 <code>Function</code> 构造函数创建的。</p>
</li>
<li>
<p>每个函数都是 <code>Function</code> 类型的实例，而 <code>Function</code> 是 <code>Object</code> 的子类型。</p>
</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">function foo() {
  console.log('Hello, world!');
}

console.log(foo instanceof Function); // 输出: true
console.log(foo instanceof Object);   // 输出: true
</code></pre>
<ul>
<li>
<p><strong>解释</strong>：</p>
<ul>
<li><code>foo</code> 是 <code>Function</code> 的实例，同时也是 <code>Object</code> 的实例。</li>
</ul>
</li>
</ul>
<hr />
<h4><a id="2%C2%A0%E5%87%BD%E6%95%B0%E5%85%B7%E6%9C%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. <strong>函数具有对象的特性</strong></h4>
<ul>
<li>
<p>函数可以像普通对象一样拥有属性和方法。</p>
</li>
<li>
<p>函数可以作为参数传递，也可以作为返回值。</p>
</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">function foo() {
  console.log('Hello, world!');
}

// 为函数添加属性
foo.name = 'myFunction';
foo.description = 'This is a function';

console.log(foo.name); // 输出: myFunction
console.log(foo.description); // 输出: This is a function

// 将函数作为参数传递
function bar(func) {
  func();
}

bar(foo); // 输出: Hello, world!
</code></pre>
<ul>
<li>
<p><strong>解释</strong>：</p>
<ul>
<li>
<p>函数 <code>foo</code> 可以像普通对象一样添加属性。</p>
</li>
<li>
<p>函数 <code>foo</code> 可以作为参数传递给另一个函数 <code>bar</code>。</p>
</li>
</ul>
</li>
</ul>
<hr />
<h4><a id="3%C2%A0%E5%87%BD%E6%95%B0%E6%98%AF%E2%80%9C%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91%E2%80%9D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. <strong>函数是“一等公民”</strong></h4>
<ul>
<li>
<p>在 JavaScript 中，函数是“一等公民”（First-class Citizen），这意味着函数可以：</p>
<ul>
<li>
<p>赋值给变量。</p>
</li>
<li>
<p>作为参数传递给其他函数。</p>
</li>
<li>
<p>作为返回值从其他函数中返回。</p>
</li>
<li>
<p>存储在数据结构中（如数组、对象）。</p>
</li>
</ul>
</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">// 赋值给变量
const myFunc = function() {
  console.log('Hello, world!');
};

// 作为参数传递
function callFunction(func) {
  func();
}

callFunction(myFunc); // 输出: Hello, world!

// 作为返回值
function createFunction() {
  return function() {
    console.log('This is a new function!');
  };
}

const newFunc = createFunction();
newFunc(); // 输出: This is a new function!
</code></pre>
<h4><a id="4%C2%A0%E5%87%BD%E6%95%B0%E6%98%AF%E2%80%9C%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E2%80%9D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. <strong>函数是“可调用对象”</strong></h4>
<ul>
<li>函数是一种特殊的对象，它不仅可以拥有属性和方法，还可以被调用（通过 <code>()</code> 调用）。</li>
</ul>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h4>
<pre><code class="language-javascript">function foo() {
  console.log('Hello, world!');
}

// 调用函数
foo(); // 输出: Hello, world!

// 为函数添加属性
foo.description = 'This is a function';
console.log(foo.description); // 输出: This is a function
</code></pre>
<hr />
<h3><a id="%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E6%AE%8A%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>函数的特殊属性</h3>
<p>函数作为对象，具有一些特殊的属性：</p>
<ol>
<li>
<p><strong><code>name</code></strong>：</p>
<ul>
<li>
<p>函数的名称。</p>
</li>
<li>
<p>例如：</p>
</li>
</ul>
<pre><code class="language-javascript"> function foo() {}
 console.log(foo.name); // 输出: foo
</code></pre>
</li>
<li>
<p><strong><code>length</code></strong>：</p>
<ul>
<li>
<p>函数期望的参数个数。</p>
</li>
<li>
<p>例如：</p>
</li>
</ul>
<pre><code class="language-javascript"> function bar(a, b, c) {}
 console.log(bar.length); // 输出: 3
</code></pre>
</li>
<li>
<p><strong><code>prototype</code></strong>：</p>
<ul>
<li>
<p>函数的 <code>prototype</code> 属性指向一个对象，这个对象是构造函数创建的实例的原型。</p>
</li>
<li>
<p>例如：</p>
</li>
</ul>
<pre><code class="language-javascript"> function Person(name) {
     this.name = name;
 }
 console.log(Person.prototype); // 输出: { constructor: Person }
</code></pre>
</li>
</ol>
<hr />
<h3><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h3>
<ul>
<li>
<p>函数是 JavaScript 中的一种对象，是 <code>Function</code> 类型的实例。</p>
</li>
<li>
<p>函数具有对象的所有特性，可以拥有属性和方法，可以作为参数传递，也可以作为返回值。</p>
</li>
<li>
<p>函数是“一等公民”，是“可调用对象”。</p>
</li>
<li>
<p>理解函数是对象这一特性，是掌握 JavaScript 函数式编程和面向对象编程的关键。</p>
</li>
</ul>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数组方法列表]]></title>
    <link href="justbb.fun/17416119491548.html"/>
    <updated>2025-03-10T21:05:49+08:00</updated>
    <id>justbb.fun/17416119491548.html</id>
    <content type="html">
<![CDATA[<table>
<thead>
<tr>
<th>方法名</th>
<th>修改原数组</th>
<th>方法执行后返回值</th>
<th>函数功能</th>
<th>备注</th>
<th>文档链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>push</td>
<td>是</td>
<td>原数组length值</td>
<td>修改数组</td>
<td>添加数据到数组末尾</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push">链接</a></td>
</tr>
<tr>
<td>pop</td>
<td>是</td>
<td>被删除的元素</td>
<td>修改数组</td>
<td>删除数组末尾最后一个数据</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/pop">链接</a></td>
</tr>
<tr>
<td>shift</td>
<td>是</td>
<td>被删除的元素</td>
<td>修改数组</td>
<td>删除数组开头第一个元素</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/shift">链接</a></td>
</tr>
<tr>
<td>unshift</td>
<td>是</td>
<td>原数组的length值</td>
<td>修改数组</td>
<td>给数组开头添加数据</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift">链接</a></td>
</tr>
<tr>
<td>splice</td>
<td>是</td>
<td>被删除的数据组成的一个新数组</td>
<td>修改数组</td>
<td>删除或添加数据到数组中</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/splice">链接</a></td>
</tr>
<tr>
<td>slice</td>
<td>否</td>
<td>新数组</td>
<td>获取数组中部分数据</td>
<td>赋值数组中的数据</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice">链接</a></td>
</tr>
<tr>
<td>*forEach</td>
<td>否</td>
<td>无</td>
<td>处理数据</td>
<td>遍历，无返回值（undefined）</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">链接</a></td>
</tr>
<tr>
<td>*map</td>
<td>否</td>
<td>新数组</td>
<td>处理数据</td>
<td>遍历，返回新数组</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map">链接</a></td>
</tr>
<tr>
<td>*some</td>
<td>否</td>
<td>布尔值</td>
<td>判断</td>
<td>只要有检测函数返回真值，返回true</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some">链接</a></td>
</tr>
<tr>
<td>*filter</td>
<td>否</td>
<td>新数组</td>
<td>获取数组中部分数据</td>
<td>返回符合检测函数的数据组成的新数组</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">链接</a></td>
</tr>
<tr>
<td>*every</td>
<td>否</td>
<td>布尔值</td>
<td>判断</td>
<td>所有数据的检测函数都返回真值，返回true</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every">链接</a></td>
</tr>
<tr>
<td>*reduce</td>
<td>否</td>
<td>累加器中的数据</td>
<td>数据处理并加总</td>
<td>返回累加器中的数据</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">链接</a></td>
</tr>
<tr>
<td>*reduceRight</td>
<td>否</td>
<td>累加器中的数据</td>
<td>数据处理并加总</td>
<td>返回累加器中的数据</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">链接</a></td>
</tr>
<tr>
<td>*sort</td>
<td>是</td>
<td>原数组</td>
<td>排序</td>
<td>排序专用</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort">链接</a></td>
</tr>
<tr>
<td>reverse</td>
<td>是</td>
<td>原数组</td>
<td>排序</td>
<td>反向排序</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse">链接</a></td>
</tr>
<tr>
<td>*findIndex</td>
<td>否</td>
<td>索引值</td>
<td>找索引</td>
<td>检测函数返回true，那么返回该数据的索引值</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex">链接</a></td>
</tr>
<tr>
<td>indexOf</td>
<td>否</td>
<td>索引值</td>
<td>找索引</td>
<td>返回第一个匹配数据的索引值（从左向右查）</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf">链接</a></td>
</tr>
<tr>
<td>lastIndexOf</td>
<td>否</td>
<td>索引值</td>
<td>找索引</td>
<td>返回最后一个匹配数据的索引值（从右往左查）</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf">链接</a></td>
</tr>
<tr>
<td>*find</td>
<td>否</td>
<td>元素</td>
<td>找元素</td>
<td>返回检测函数返回真值的数据</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/find">链接</a></td>
</tr>
<tr>
<td>includes</td>
<td>否</td>
<td>布尔值</td>
<td>判断</td>
<td>如果传入的数据在数组中有，就返回true</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes">链接</a></td>
</tr>
<tr>
<td>concat</td>
<td>否</td>
<td>新数组</td>
<td>合并数组</td>
<td>原数组合并传入的数据（任何数据）到一个新数组</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat">链接</a></td>
</tr>
<tr>
<td>fill</td>
<td>是</td>
<td>原数组</td>
<td>修改数组</td>
<td>用某个数据覆盖填充数组中的数据</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill">链接</a></td>
</tr>
<tr>
<td>copyWithin</td>
<td>是</td>
<td>原数组</td>
<td>修改数组</td>
<td>用数组中的部分数据覆盖原数组中的指定索引位数据</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/copuWithin">链接</a></td>
</tr>
<tr>
<td>join</td>
<td>否</td>
<td>字符串</td>
<td>转字符串</td>
<td>链接所有数据为字符串</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/join">链接</a></td>
</tr>
<tr>
<td>keys</td>
<td>否</td>
<td>可迭代对象</td>
<td>产生可迭代对象</td>
<td>键值，就是属性名（都是数字）</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/keys">链接</a></td>
</tr>
<tr>
<td>values</td>
<td>否</td>
<td>可迭代对象</td>
<td>产生可迭代对象</td>
<td>值，数组中的数据</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/values">链接</a></td>
</tr>
<tr>
<td>entries</td>
<td>否</td>
<td>可迭代对象</td>
<td>产生可迭代对象</td>
<td>键值对，数组的形式，前面是属性名，后面是值</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/entries">链接</a></td>
</tr>
</tbody>
</table>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[小孩为啥很可爱]]></title>
    <link href="justbb.fun/17414463963213.html"/>
    <updated>2025-03-08T23:06:36+08:00</updated>
    <id>justbb.fun/17414463963213.html</id>
    <content type="html">
<![CDATA[<p>当了爸爸后，总感觉自己的娃挺可爱。</p>
<p>这种感觉可爱似乎是刻在家长基因里的。</p>
<p>孩子头大，肩膀小，手臂向上伸，可能超不过脑袋。</p>
<p>皮肤光滑，面色红润，胖乎乎的脸蛋，看到就想摸。</p>
<p>今天查了一下为什么感觉小孩可爱，居然还有专业术语的，这种情况叫<a href="https://pansci.asia/archives/184914">「丘比特娃娃效应」</a>，是一种广泛存在在哺乳动物幼崽的状态，比如小猫，小狗，小狮子等。</p>
<p>似乎是一种天然的建立依附关系的方法。</p>
<blockquote>
<p>丘比娃娃最早是由美國羅絲‧歐尼爾 （Rose O’Neill）在 1909 年所創造出的角色，擁有圓潤的雙眸，對稱且圓滾的身體，並依據愛神邱比特的諧音取名，在推出的短時間內就造成極大的轟動。</p>
</blockquote>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[孩子叛逆怎么办]]></title>
    <link href="justbb.fun/17414456449769.html"/>
    <updated>2025-03-08T22:54:04+08:00</updated>
    <id>justbb.fun/17414456449769.html</id>
    <content type="html">
<![CDATA[<p>听曹操来了讲<a href="https://www.douyin.com/video/6953830580454853895">带娃</a>，他是一个在中国生活了二十多年的老外，对中美文化都很了解，看他视频也感觉他活得很通透，对很多现象都有自己的理解。</p>
<p>他女儿最近想穿舌钉，作为爸爸肯定觉得这种有点危险，觉得女儿考虑的不全面，真穿了多半会后悔。<br />
但14岁的叛逆期的孩子，直接说肯定不会听你的，作为家长有什么办法吗？</p>
<p>曹操给的建议就是拖一下，她让孩子认真考虑一个月，一个月后如果还想打，就带她打。</p>
<p>这段时间，可以让她好好冷静一下，她可能会去找一些打舌钉的好与坏，然后就渐渐对它失去兴趣了。</p>
<p>但最大概率其实是，她可能忘了。</p>
<p>所以这个问题就解决了。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[试着用 AI 写 word 脚本]]></title>
    <link href="justbb.fun/17412722521826.html"/>
    <updated>2025-03-06T22:44:12+08:00</updated>
    <id>justbb.fun/17412722521826.html</id>
    <content type="html">
<![CDATA[<p>最近总是有很多合同要处理，但其实合同模板都是一样的，只是里面的甲方对象不同，所以突然想到word其实有vba宏可以使用。<br />
所以让AI帮我写了个脚本，自己稍加改动就可以运行。<br />
目前就是界面还不太友好，全是弹窗，下一步试试改下界面。</p>
<pre><code class="language-plain_text">Sub GenerateContract()
    ' 声明变量
    Dim doc As Document
    Dim partyA As String    ' 甲方名称
    Dim partyAAddress As String    ' 甲方地址
    Dim partyAContact As String    ' 甲方联系人
    Dim contractDate As String     ' 合同日期
    Dim contractNo As String       ' 合同编号
    
    ' 获取用户信息（这里可以通过输入框或指定单元格获取）
    partyA = InputBox(&quot;请输入甲方名称：&quot;)
    partyAAddress = InputBox(&quot;请输入甲方地址：&quot;)
    partyAContact = InputBox(&quot;请输入甲方联系人：&quot;)
    contractDate = Format(Date, &quot;yyyy年mm月dd日&quot;)
    contractNo = &quot;FG&quot; &amp; Format(Date, &quot;yyyymmdd&quot;) &amp; &quot;-&quot; &amp; Format(Time, &quot;hhmm&quot;)
    
    ' 打开模板文档
    Set doc = Documents.Open(&quot;/Users/lay/Dropbox/客户QA/合同模板/ContractTemplate.doc&quot;) ' 修改为你的模板路径
    
    ' 替换模板中的占位符
    With doc
        ' 假设模板中使用 {PartyA} 这样的占位符
        .Application.Selection.Find.Execute FindText:=&quot;{PartyA}&quot;, _
            replaceWith:=partyA, Replace:=wdReplaceAll
        .Application.Selection.Find.Execute FindText:=&quot;{PartyAAddress}&quot;, _
            replaceWith:=partyAAddress, Replace:=wdReplaceAll
        .Application.Selection.Find.Execute FindText:=&quot;{PartyAContact}&quot;, _
            replaceWith:=partyAContact, Replace:=wdReplaceAll
        .Application.Selection.Find.Execute FindText:=&quot;{ContractDate}&quot;, _
            replaceWith:=contractDate, Replace:=wdReplaceAll
        .Application.Selection.Find.Execute FindText:=&quot;{ContractNo}&quot;, _
            replaceWith:=contractNo, Replace:=wdReplaceAll
    End With
    
    ' 另存为新文档
    doc.SaveAs2 FileName:=&quot;/Users/lay/Dropbox/客户QA/合同模板/&quot; &amp; PartyA &amp; &quot;飞鸽劳务通SaaS软件系统及抖音招聘账号报白使用权益服务合同_&quot; &amp; contractNo &amp; &quot;.doc&quot;
    
    ' 可选择是否关闭文档
    ' doc.Close
    
    MsgBox &quot;合同已生成！保存路径：/Users/lay/Dropbox/客户QA/合同模板/合同_&quot; &amp; contractNo &amp; &quot;.doc&quot;
    
    ' 清理
    Set doc = Nothing
End Sub

</code></pre>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从两岸报告看中国的经济股市与美元的汇率转折]]></title>
    <link href="justbb.fun/17419289426793.html"/>
    <updated>2025-03-14T13:09:02+08:00</updated>
    <id>justbb.fun/17419289426793.html</id>
    <content type="html">
<![CDATA[<p>WB会员文章：</p>
<p>近期太平洋两岸分别作了一年一度的政府报告，当然在美国那边叫作国情咨文。美国的国情咨文和中国的政府工作报告分属逻辑完全不同的政治传统，对于美国政治来说，国情咨文更重要的是动员、煽动、团结的作用，更像一场show，是在直接选举体制下的一种更具仪式性的行为。中国的政府工作报告则更像是理性计划时代的延续，没有那么多表演成分，重点都是实实在在的数字KPI。但由于现代经济的复杂性和多变性，政府工作报告对于政策取向的表述更多只是反应当下时点的。现代社会治理经济最长也要按月思考决策，用飞行员开飞机来比喻再合适不过，尤其是遇到关键的节点，几个月没开好就有撞机和偏航的风险。</p>
<p>今年中国政府工作报告整体上中规中矩，既没有超预期也没有不及预期，延续了去年9月份以来的基调。同时由于去年9月份开始经济整体向好的势头愈发明显，本次报告也没有再给更进一步超预期的信号。最能说明的就是赤字率安排在4%，其实这个赤字率没什么用，因为政府债务的真实赤字远大于每年公告的这个数，报告中提到的这个数一般被称为“狭义赤字”。狭义赤字的信号意义大于实际意义，今年的4%是自08年以来最高的一次赤字率，但同时也并没有达到去年一些学者公开建议的5%水平，体现了一种保持积极基调下的折中态度，也为后续需要更大刺激留了后手。</p>
<p>如果我们将更接近真实赤字水平的超长期特别国债、专项债、特别国债这三个也考虑进赤字后，那么赤字率的可比水平将从2024年的6.6%增加到2025年的8.4%，这个增加力度也是不小的。针对市场上近期流传的一些由于经济回暖政府刺激政策有阶段性收缩的观点，我觉得可能有一些体现这个思路的货币政策操作，但这并不改变目前整体上仍然以超常规逆周期调节为方向的总基调。</p>
<p>关于股市层面，本次报告有提到“加强战略性力量储备和稳市机制建设”，这个被市场理解为有可能进一步加强中长期资金入市和平准基金类资金入市的政策。但这方面我们之前的文章分析的一个基本思路是，除非平准基金和可动用的中长期资金体量足够大，否则很难对股市产生根本性影响，而目前的国内可动用资金体量相较于A股庞大的流通市值可以说是杯水车薪，所以救市资金更重要的是发挥股灾兜底，而非牛市催生的作用。</p>
<p>但从2月份以来，股市的变化，尤其是港股的变化出现了一些积极的信号。这轮的港股上涨带有“讲故事氛围”的巨大变化。除了和AI概念沾边的科技股行情，还有一些其他的现象——如B站在发布了一份和上季度基本面差不多的财报后股价波动出现了巨大差别，特朗普加征关税的心理影响也没有阻挡港股上涨的大趋势等等。本轮上涨能否真正带动一次港股牛市越来越值得期待。当然，跟我们分析时间比较长的听友应该知道我核心的观点仍然，港股的上涨最根本的原因是估值足够低，跌的足够久。在这种情况下，任何概念和叙事氛围的变化最后都可能催生一波真正的牛市，即使现在没有DeepSeek大家最终也会找到其他的理由。同理，美股的下跌也是早晚会出现的事，巴菲特并不知道中国今年会有DeepSeek，但他仍然在1年前就开始大幅减持美股。</p>
<p>除了宏观政策与股市以外，我在去年9月新政之后持续关注了北京二手房成交情况，到目前为止数据一直保持在比较好的状态。同时我们看到以10年期国债为代表的长期市场利率自2月份以来也出现了明显的触底反弹。这些信号都在预示，中国本轮自2023年下半年开始的流动性陷阱有可能逐步的出现转折。当然，预测宏观经济本身就是很困难的事，未来是否还会遇到其他不确定性的事件我们无法预测。唯一能让我们保持长期盈利的方式只有在低估值阶段建仓。</p>
<p>另一方面，美国目前的经济形势普遍被市场认为可能面临从增长到滞胀的转折。从正常的短经济周期来说，美国这一轮的上行周期已经持续了很久，即使没有其他干扰因素，阶段性衰退的可能性也已经越来越大。同时由于美股出现了极端高估的情况，如果后续的阶段性衰退跌加了美国崩盘，那么财富缩水的效应会进一步给美国经济带来打击。而通胀的延续主要是由于特朗普关税政策的影响。</p>
<p>关于美股的高估问题我们已经在12月份的时候写过文章《美股的高估与范式转移风险》。而关税问题我们一直以来都持有一个判断，即特朗普并非单纯的以提高关税为目标，其最终目标应是减少美国的货物贸易逆差以及增加美国本土FDI投资。达成这个目标既可以靠关税，也可以靠美元汇率贬值，故其最终有可能以关税作为谈判筹码，最终通过汇率与关税的组合方式实现其目标，关于这方面的原理，我们在会员文章《关于特朗普“对华50%关税”政策的理解》（2024-7-18）也有过详细的阐述，感兴趣的朋友可以参考。</p>
<p>当下的形势来看，汇率变化更有可能是达成各方平衡的首选。首先，中国国内的宏观经济回暖和市场利率的上行本身就会改变外汇投机市场的预期，造成人民币升值。同时二级市场资产重估的股市也会带动国际热钱兑换人民币，进一步加强人民币的升值趋势（同时也对应美元被卖出的趋势）。而在美国方面，利用美元贬值实现贸易目标，可以减少最终的实际关税加征，也可以减少国内通胀的预期，所以当下的逻辑有可能是国内通胀数据越高，特朗普加征关税政策的阻力就会越大，从而导致特朗普更倾向于使用汇率工具实现目标，这也可能是近期美元汇率波动一反之前的通胀上行——加息预期——美元升值的传导逻辑，而出现了通胀上行——美元贬值的市场现象。特朗普从关税到汇率的政策工具变化，本质上就是将美国的国内通胀转嫁为国际市场上的美元贬值。</p>
<p>总结来说，如果目前中国经济回暖和二级市场上涨的趋势得到确立，且美国的通胀趋势不减的话，那么人民币和美元的汇率转折风险将会越来越大。当中国走出流动性陷阱的时候，美国要么选择滞胀，要么选择美元贬值。而这个选择题对于任何一位脑子不傻的美国领导人来说都是极为简单的，更何况是特朗普。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为什么中国C端大厂，产品名都挺低龄]]></title>
    <link href="justbb.fun/17412489236160.html"/>
    <updated>2025-03-06T16:15:23+08:00</updated>
    <id>justbb.fun/17412489236160.html</id>
    <content type="html">
<![CDATA[<blockquote><p lang="zh" dir="ltr">全中国的互联网产品命名法。主要是面对C端的。名字和logo都非常接地气。菜鸟，咸鱼，XX宝，天猫。其实是普通消费者教育程度和想象力还是不高。必须贴地飞行才能深入人心。 就连领导讲话也是一样。 <a href="https://t.co/rF7Sqs6ELr">https://t.co/rF7Sqs6ELr</a></p>&mdash; David Chang (@David_yc607) <a href="https://twitter.com/David_yc607/status/1897509483406147671?ref_src=twsrc%5Etfw">March 6, 2025</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>最近看到大卫分享了一个国内产品起名的背景，挺有意思的。其实不光是产品名称，很多时候国内的产品形象，也有大量低幼设计元素，比如派出所的一些宣传海报，人物均是卡通式的警察。</p>
<p>但也要知道事物都是在发展的，这种「低幼化」的设计，总好过直接的白底黑字那种，一点都不「亲民」的设计。未来这些设计肯定会随着人群认知，逐渐发生变化的。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[老家好热闹]]></title>
    <link href="justbb.fun/17410999349418.html"/>
    <updated>2025-03-04T22:52:14+08:00</updated>
    <id>justbb.fun/17410999349418.html</id>
    <content type="html">
<![CDATA[<p>这几年年轻人都往城里跑，乡里人越来越少，当年的小学中学啥的都拆了。本以为老家会因为人越来越少变得越来越归于平淡。<br />
但偶尔看到了老家的亲戚发了一个老家在举行篝火晚会的视频。视频里大家围着篝火又唱又跳，远处还搭有舞台，灯光闪烁，宛若一个小音乐节。<br />
这是在我以前不太能想象的，因为我的老家其实离镇上挺远的，总觉得不会有这些“现代”的东西。<br />
后来仔细了解到，原来是政府打算在此搞的景观农业观赏地，花了不少钱平整了土地，种了油菜花，修了步行道，偶尔会做一些活动招商。也让这比较平淡的乡里多了不少人气。<br />
<img src="media/17410999349418/17411005612564.jpg" alt="" /></p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何在网页中嵌入推文]]></title>
    <link href="justbb.fun/17412568701695.html"/>
    <updated>2025-03-06T18:27:50+08:00</updated>
    <id>justbb.fun/17412568701695.html</id>
    <content type="html">
<![CDATA[<p>最近刷推刷的比较多，偶尔看到一些有意思的推文，就想记录下来。然后就想到了其实可以在博文中插入推文，检索了一下，其实方法很简单。</p>
<ol>
<li>复制推文 URL 链接</li>
<li>在 <a href="https://publish.twitter.com/#">publish.twitter.com</a> 粘贴 URL 链接</li>
<li>选择合适的样式</li>
<li>在博文中直接粘贴代码片段，done</li>
</ol>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[朋友分享了他带娃的一些经验]]></title>
    <link href="justbb.fun/17409265995349.html"/>
    <updated>2025-03-02T22:43:19+08:00</updated>
    <id>justbb.fun/17409265995349.html</id>
    <content type="html">
<![CDATA[<p>朋友今天来吃饭，和他交流了一些育儿经验：</p>
<ul>
<li>我问你担心孩子拆家吗，他说他不太担心，主要想还是要对孩子有耐心，多讲道理，不要对孩子发脾气，因为孩子其实是回学你的，一旦孩子叛逆了，那孩子也会学你发脾气来对付你。</li>
<li>他家里有很多零食，小朋友没有经允许的情况偶尔也会偷偷去拿，但他不会特别生气，也不会对但零食上锁，他说，堵不如疏，还是要多给他沟通，能让他学会控制自己是最好的。</li>
<li>关于兴趣班，他会经常带孩子去，但不是为了真的学东西，主要是兴趣，可以换着来，主要还是交朋友长见识。</li>
<li>关于近视，控制手机是一方面，但一定要带孩子多去户外，虽然他孩子玩手机玩的也挺勤，但现在5岁了，眼睛依然没啥毛病。</li>
<li>弹钢琴：他表示会带孩子弹钢琴，一方面钢琴是声部很全很适合独奏的乐器，另外钢琴需要左右手协调，是很锻炼大脑的，所以学钢琴也不是为了成才，但可以锻炼大脑还是不错。</li>
</ul>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[双减政策后，教育更公平了吗]]></title>
    <link href="justbb.fun/17406340897483.html"/>
    <updated>2025-02-27T13:28:09+08:00</updated>
    <id>justbb.fun/17406340897483.html</id>
    <content type="html">
<![CDATA[<p>近年来，“双减”政策（减轻学生作业负担和校外培训负担）成为教育领域的热门话题。政策的初衷是为了减轻学生压力、促进教育公平，但最近一项研究却揭示了令人深思的结果：双减政策可能加剧了教育资源的分化，高收入家庭的学生受益更多，而低收入家庭的学生却面临更大的挑战。</p>
<p>这个研究来源于北京大学周子焜，雷晓燕，沈艳团队做的论文《教育减负、家庭教育支出与教育公平》，主要是评估义务教育阶段，对降低学生课业负担和校外培训负担后，学生学习时间变化，升学率等指标做相关性研究。</p>
<p>最后根据调研结果进行回归分析，研究人员发现了一个令人担忧的趋势，家庭收入分位数为前46%的，在教育减负后升学变的更加容易，但在后54%的家庭在教育减负后，虽然家庭支出变少了，但升学变的更困难了。</p>
<p><strong>低收入家庭的学生：</strong></p>
<ul>
<li>升入高中的概率平均下降了 9.3%</li>
<li>教育总开支平均减少了 21%</li>
<li>每周学习时间平均减少了 9.19 个小时</li>
</ul>
<p><strong>高收入家庭的学生：</strong></p>
<ul>
<li>升入高中的概率平均上升了 5.3 个百分点</li>
<li>教育总开支平均增加了 67%</li>
<li>每周学习时间平均增加了 10.37 个小时</li>
</ul>
<p>这不禁开始让人反思政策的实施与现实的复杂性，政策的初衷当然是好的，希望通过减少学生的课业负担和校外培训，让教育回归学校，减轻家庭的经济压力，促进教育公平。然而，现实却远比理想复杂，主要在于：</p>
<ol>
<li>教育资源分配不均，优质的教育资源通常还是居中在少数学校及家庭中，这个靠短期政策是无法解决的。</li>
<li>家庭经济能力的差异，中国地域辽阔，东西城乡，家庭收入差距比较大，高收入家庭能够通过增加个人教育投入抵消政策影响，而低收入家庭则承担了更多政策影响。</li>
<li>教育竞争依然加剧，目前虽然生育率在降低，但依然有大量学龄人员，通过高考等形式的教育竞争压力依然存在，只要竞争存在，政策减负的效果就容易被家庭的加码所抵消。<br />
双减政策的实施让我们看到了教育改革的复杂性。虽然政策的初衷是好的，但在执行过程中，如何避免加剧教育资源的分化，如何真正惠及所有家庭，仍然是一个需要深入思考和解决的问题。</li>
</ol>
<p>教育公平不仅是政策的责任，更是全社会的共同目标。只有通过多方努力，才能真正实现“让每个孩子都能享有公平而有质量的教育”的愿景。</p>
<p>论文地址：<a href="https://nsd.pku.edu.cn/docs/20230719145943514162.pdf">https://nsd.pku.edu.cn/docs/20230719145943514162.pdf</a></p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[抖音折叠]]></title>
    <link href="justbb.fun/17406420399500.html"/>
    <updated>2025-02-27T15:40:39+08:00</updated>
    <id>justbb.fun/17406420399500.html</id>
    <content type="html">
<![CDATA[<p>最近刷视频号，偶尔会看到一些很奇怪的账号，里面全是一些负能量的内容。</p>
<p>但根据内容的连续性看，感觉又不像是一个人发的生活，而是东拼西凑找的视频上传的。</p>
<p>画面背景一般是农村家庭。</p>
<p>内容一般是妈妈打小孩，孩子哭的撕心裂肺；婆媳矛盾激烈，把家里的锅碗瓢盆都砸了；孩子不睡觉，妈妈想掐死孩子等。</p>
<p><img src="media/17406420399500/17406424735718.jpg" alt="" /></p>
<p>这些内容看起来不太像是摆拍，但看了后就让人感觉他们在另一个世界一样。</p>
<p>不禁让人想到，抖音或视频号的审核人员，每天大概会看到更多这种负能量的内容吧，而且这些内容还是真实的，有时候还是感叹，算法编织的信息茧房，让我们以为世界很美好，但其实真实的世界已经被折叠了。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DeepSeek 工具]]></title>
    <link href="justbb.fun/17406437029217.html"/>
    <updated>2025-02-27T16:08:22+08:00</updated>
    <id>justbb.fun/17406437029217.html</id>
    <content type="html">
<![CDATA[<h3><a id="%F0%9F%94%8D%E6%90%9C%E7%B4%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>🔍搜索</h3>
<ol>
<li>秘塔搜索👍：<a href="https://metaso.cn">https://metaso.cn</a></li>
<li>360纳米AI搜索👍：<a href="https://www.n.cn/">https://www.n.cn/</a></li>
<li>知乎直答：<a href="https://zhida.zhihu.com">https://zhida.zhihu.com</a></li>
</ol>
<h3><a id="%F0%9F%92%BB%E4%BA%91%E6%9C%8D%E5%8A%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>💻云服务</h3>
<ol>
<li>硅基流动：<a href="https://cloud.siliconflow.cn/i/WQCfCBuF">https://cloud.siliconflow.cn/i/WQCfCBuF</a></li>
<li>派欧算力云：<a href="https://ppinfra.com/user/register">https://ppinfra.com/user/register</a></li>
<li>阿里云百炼：<a href="https://api.together.ai/playground/chat/deepseek-ai/DeepSeek-R1">https://api.together.ai/playground/chat/deepseek-ai/DeepSeek-R1</a></li>
<li>字节跳动火山引擎：<a href="https://console.volcengine.com/ark/region:ark+cn-beijing/experience">https://console.volcengine.com/ark/region:ark+cn-beijing/experience</a></li>
<li>百度云千帆：<a href="https://console.bce.baidu.com/qianfan/modelcenter/model/buildIn/list">https://console.bce.baidu.com/qianfan/modelcenter/model/buildIn/list</a></li>
<li>英伟达：<a href="https://build.nvidia.com/deepseek-ai/deepseek-r1">https://build.nvidia.com/deepseek-ai/deepseek-r1</a></li>
<li>Groq：<a href="https://groq.com/">https://groq.com/</a></li>
<li>Fireworks：<a href="https://fireworks.ai/models/fireworks/deepseek-r1">https://fireworks.ai/models/fireworks/deepseek-r1</a></li>
<li>Chutes：<a href="https://chutes.ai/app/chute/">https://chutes.ai/app/chute/</a></li>
</ol>
<h3><a id="%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>应用</h3>
<ol>
<li>华为小艺：<a href="https://xiaoyi.huawei.com/chat/">https://xiaoyi.huawei.com/chat/</a></li>
<li>Wolai：<a href="https://www.wolai.com">https://www.wolai.com</a></li>
<li>超算互联网：<a href="https://www.scnet.cn/">https://www.scnet.cn/</a></li>
<li>支付宝百宝箱：<a href="https://tbox.alipay.com/communit">https://tbox.alipay.com/communit</a></li>
</ol>
<h3><a id="%F0%9F%93%96%E8%B5%84%E6%96%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>📖资料</h3>
<ol>
<li>deepseek飞书资料库：<a href="https://acnawnoo7ng6.feishu.cn/wiki/FzozwGlZ2i6RTwkEJNZcYGMOnib">https://acnawnoo7ng6.feishu.cn/wiki/FzozwGlZ2i6RTwkEJNZcYGMOnib</a></li>
<li>清华大学 DeepSeek 最新合集，链接: <a href="https://pan.quark.cn/s/b76796cc28c1">https://pan.quark.cn/s/b76796cc28c1</a></li>
<li>厦门大学 140 页 PPT《Deepseek 大模型概念、技术与应用实践》，链接: <a href="https://pan.quark.cn/s/0747f92fba2d">https://pan.quark.cn/s/0747f92fba2d</a></li>
<li>小白也可以！离线免费用 Deepseek本地傻瓜式安装部署流程：<a href="https://acnawnoo7ng6.feishu.cn/wiki/DpbywtO23i7T7wkdO3dca30Qnrf">https://acnawnoo7ng6.feishu.cn/wiki/DpbywtO23i7T7wkdO3dca30Qnrf</a></li>
</ol>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[5月前的投资计划]]></title>
    <link href="justbb.fun/17403877754049.html"/>
    <updated>2025-02-24T17:02:55+08:00</updated>
    <id>justbb.fun/17403877754049.html</id>
    <content type="html">
<![CDATA[<p>节前科技股和中小盘股，特别是港股，已经有过一轮暴涨，现在风险已经比较高了。</p>
<p>比如可以看TMT版块拥挤指数（单日TMT版块成交金额/A股单日总成交金额）已经突破了历史最高值（40%），现在是44%。美国的历史最高值也就是45%-50%左右。历史上看，每当到极值时，回调概率会加大。</p>
<p>而且柯创板的估值PE-TTM已经来到了88倍，历史百分位达到了98%，也是很接近历史高点了。</p>
<p>恒生科技的估值水平也来到了21年9月的水平。</p>
<p>总之<strong>中国科技资产已经不便宜了</strong>。</p>
<h3><a id="%E5%88%B05%E6%9C%88%E5%89%8D%E7%9A%84%E6%93%8D%E4%BD%9C%E6%80%9D%E8%B7%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>到5月前的操作思路</h3>
<p>根据历史经验，每年的两会前后，市场交投情绪和市场风险偏好会达到峰值，但这股情绪会推动市场在4月上旬达峰之后快速回落。</p>
<p>所以建议选择**“避开TMT版块的高位博弈，去布局目前的低位版块，静待4月下旬到5月上旬的风格切换**</p>
<p>虽然长周期看，隐隐有让传统高股息，传产资金向科技板块流动，实现财富的世代更替的意思，但是以年为尺度来观察，历史的周期性规律仍然没有那么容易打破。</p>
<p>因此，我们应该布局哪些板块呢，如果是我，我会考虑上游资源股。因为上游很多领域是供给侧改革做的比较好的领域，供给侧做的好意味着价格弹性好，一旦需求侧出现积极变化，上游很有可能出现 “困境反转”。比如：</p>
<p>1） 已经持续下行三年的钢铁，在新的供给侧改革文件出台之后，是否有困境反转的机会？</p>
<p>2） 又或是最近突然生猪板块出现大涨，可能也是猪肉在长期底部上的静极思动？</p>
<p>3） 人形机器人可能量产在即，会不会出现类似当年磷酸铁锂电池铺开之后“盐湖提锂”概念的飞上天？要知道无论是机器人的空心杯电机，还是矩形框电机（这个其实两年前我就提到过），永磁材料都是核心原材料，是否会出现类似过去新能源“原材料涨到关键零组件涨到整机”的“长江三叠浪”？</p>
<p><img src="media/17403877754049/17404015752782.jpg" alt="" /></p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[带娃的乐趣]]></title>
    <link href="justbb.fun/17404732653043.html"/>
    <updated>2025-02-25T16:47:45+08:00</updated>
    <id>justbb.fun/17404732653043.html</id>
    <content type="html">
<![CDATA[<p>看小红书，说鲁迅带娃也是容易崩溃的，鲁迅在书信中说，</p>
<blockquote>
<p>孩子颇胖，而太顽皮，闹得人头昏。<br />
——1931.06.23 致李秉中</p>
<p>我们都好，只有那位‘海婴氏’颇为淘气，总是搅扰我的工作，上月起就把他当做敌人看待了。<br />
——1934.06.07 致增田涉</p>
<p>至于孩子，偶然看看是有趣的，但养起来，整天在一起，却真是麻烦得很。<br />
——1934.12.06 致萧军、萧红</p>
<p>孩子也好了，但他大了起来，越加捣乱，出去，就惹祸，我已经受了三家邻居的警告——但自然，这邻居也是擅长警告的邻居。但在家里，却又闹得我静不了，我希望他快过二十岁，同爱人一起跑掉，那就好了。<br />
——1935.06.07 致萧军</p>
<p>我对付自己的孩子，也十分吃力，总算已经送进幼稚园去了，每天清静半天。<br />
——1935.09.01 致萧军</p>
<p>海婴亦好，整日在家里闯祸，不是嚷吵，就是敲破东西，幸而再一礼拜，幼稚园也要开学了，要不然，真是不得了。<br />
——1936.02.01 致母亲</p>
</blockquote>
<p>鲁迅自然是大忙人，有他自己需要专注的事情，而我这种闲人是不能不关注孩子的。</p>
<p>既然带孩子，就必须要想办法带出点持久的乐趣出来，不然容易把自己搞崩溃。</p>
<p>我感觉带娃其实就和生活是一样的，都是在寻求一种安宁中的幸福，都是在期待一种掌控感中的惊喜感。</p>
<p>既然如此，带娃也是需要不断学习的，需要不断的从「专家」中汲取技巧，才能让娃不至于脱轨。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[人生的修行]]></title>
    <link href="justbb.fun/17403989692151.html"/>
    <updated>2025-02-24T20:09:29+08:00</updated>
    <id>justbb.fun/17403989692151.html</id>
    <content type="html">
<![CDATA[<p>人生修行中有诸多课题，其中两个普遍且棘手的问题——停止向外求索和解决社交关系问题——实际上比想象中更为简单。</p>
<p>核心的解决之道在于形成自我，即达到自立1.0阶段。这一阶段要求具备自信、健康的边界感、独立人格和独立思考能力，对世界和他人祛魅，从而使内在核心趋于稳定。如此一来，便能对名利、社会规训、他人影响等产生质的抵抗力，不再轻易被PUA或陷入劣质关系。对于东亚的小镇做题家而言，这一过程通常发生在30岁前后，是一个逐渐“出世”的过程。</p>
<p>在此之前，青春期快速形成的是小我（ego），而本体自我尚未跟上，因此尚不能称之为真正的自我形成。</p>
<p>自立1.0阶段其实相当常见，也是许多鸡汤博主和心理学博主所倡导的“基本”要求。</p>
<p>接下来，继续消除小我（ego），夯实本我（self），提升身心合一的状态，进一步精进自信、行动力、能动性、社交能力和实践能力。其中，经济独立能力尤为关键，即通过赚钱实现经济脱困，无需大富大贵，只需能够维持生活。这是一个重新“入世”的过程，也是通往自立2.0的奋斗历程，正如姜文所言“站着把钱挣了”的课题。当然，更重要的是自我实现的过程。这一过程可以类比为从普通心理学博主成长为武志红、曾奇峰等知名心理学家的进阶之路。</p>
<p>然而，赚钱并非仅靠个人努力，时运也起着重要作用。过度PUA自己不够努力，反而是修行不足的表现。即便是张颂文也经历了多年的奋斗，梵高最终选择了自我了断，而马克思一生也未能很好地解决经济问题。</p>
]]>
    </content>
  </entry>
  
</feed>
