<!DOCTYPE html>
<html>

<head>
    <title>
         JS：闭包 - JustBB 
    </title>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="欢迎来到JUST.bb这里是我的一个自留地，主要用来记录和分享一些工作、生活中的随笔、思考和总结。我希望通过文字，梳理自己的思路，沉淀经验，也希望能与志同道合的朋友们交流碰撞，共同成长。">

    <link rel="stylesheet" type="text/css" href="asset/cuckoo.css">
    <link rel="stylesheet" type="text/css" href="asset/main.css">
    <link rel="shortcut icon" href="asset/favicon.ico" type="image/x-icon" />
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="JustBB">

    <link rel="stylesheet" href="asset/zoom.css">

    <!-- 引入 Prism.js 核心 CSS -->
    <!-- <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" /> -->
    <link rel="stylesheet" href="asset/prism-nord.css">
    <!-- 引入 Prism.js 核心 JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
     <!-- 引入 JavaScript 语言支持 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>

</head>

<body>
    <header class="site-header cuckoo">
        <div class="wrapper">
            <a class="site-title" href="index.html">JustBB</a>
            <nav class="site-nav">
                <a href="#" class="menu-icon">
                    <svg viewBox="0 0 18 15">
                        <path fill="#424242"
                            d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z">
                        </path>
                        <path fill="#424242"
                            d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z">
                        </path>
                        <path fill="#424242"
                            d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z">
                        </path>
                    </svg>
                </a>
                <div class="trigger">
                    
                    <a class="page-link" href="index.html">Home</a>
                    
                    <a class="page-link" href="Daily.html">Daily</a>
                    
                    <a class="page-link" href="Invest.html">Invest</a>
                    
                    <a class="page-link" href="Review.html">Review</a>
                    
                    <a class="page-link" href="read.html">Books</a>
                    
                    <a class="page-link" href="about.html">About</a>
                    
                </div>
            </nav>
        </div>

        

    </header>
</body>

</html>
 <div class="page-content cuckoo">
    <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
            <header class="post-header">
                <h1 class="post-title" itemprop="name headline">JS：闭包</h1>
                <div class="post-description">
                    

                    <time datetime="2025/03/19">2025/03/19</time>
                    
                    <div class="author">@BB</div>


                </div>
            </header>
            <div class="post-content" itemprop="articleBody">
                <p><strong>闭包（Closure）</strong> 是 JavaScript 中一个非常重要的概念，它允许函数访问其词法作用域中的变量，即使函数在其词法作用域之外执行。闭包的原理和意义在 JavaScript 开发中非常关键，以下是详细说明：</p>
<hr />
<h3><a id="1%E9%97%AD%E5%8C%85%E7%9A%84%E5%8E%9F%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>1. 闭包的原理</strong></h3>
<h4><a id="1%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(1) 词法作用域</strong></h4>
<ul>
<li>
<p>JavaScript 使用<strong>词法作用域</strong>（Lexical Scope），即函数的作用域在函数定义时就已经确定，而不是在函数调用时确定。</p>
</li>
<li>
<p>函数可以访问其定义时所处的作用域中的变量。</p>
</li>
</ul>
<h4><a id="2%E9%97%AD%E5%8C%85%E7%9A%84%E5%BD%A2%E6%88%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(2) 闭包的形成</strong></h4>
<ul>
<li>
<p>当一个函数在其词法作用域之外执行时，仍然可以访问其词法作用域中的变量，这时就形成了闭包。</p>
</li>
<li>
<p>闭包的本质是函数与其词法作用域的结合。</p>
</li>
</ul>
<h4><a id="3%E9%97%AD%E5%8C%85%E5%BD%A2%E6%88%90%E7%9A%84%E6%9D%A1%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(3) 闭包形成的条件</strong></h4>
<p>闭包的形成需要满足以下条件：</p>
<ol>
<li><strong>函数嵌套：</strong> 闭包通常发生在函数内部定义了另一个函数（即嵌套函数）。外层函数提供了一个作用域环境，内层函数可以访问这个环境。</li>
<li><strong>内部函数引用外部变量：</strong> 内层函数必须引用外层函数作用域中的变量或参数。如果内层函数没有引用外层作用域的变量，就不会形成闭包。</li>
<li><strong>外部函数返回内部函数：</strong> 外层函数需要将其内部函数返回，或者以某种方式将内部函数暴露出去（比如赋值给外部变量）。这样，内部函数可以在外部函数执行完毕后仍然被调用。</li>
<li><strong>外部函数被调用且执行完成：</strong> 闭包的形成是在外层函数执行完毕后，内部函数依然能够“记住”外层函数作用域中的变量。这是由于 JavaScript 的作用域链和垃圾回收机制，外部变量不会被销毁，因为内部函数仍然持有对它们的引用。</li>
</ol>
<h4><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>示例：</strong></h4>
<pre><code class="language-javascript">function outer() {
    let count = 0; // 外层函数的变量
    function inner() { // 内层函数
        count++; // 引用外层变量
        console.log(count);
    }
    return inner; // 返回内层函数
}

const fn = outer(); // outer 执行并返回 inner
fn(); // 输出 1
fn(); // 输出 2
</code></pre>
<p>在这个例子中：</p>
<ul>
<li>
<p><code>inner</code> 函数引用了 <code>outer</code> 的变量 <code>count</code>。</p>
</li>
<li>
<p><code>outer</code> 返回了 <code>inner</code>，使得 <code>inner</code> 可以在外部被调用。</p>
</li>
<li>
<p>即使 <code>outer</code> 执行完毕，<code>count</code> 依然被 <code>inner</code> “记住”，形成了闭包。</p>
</li>
</ul>
<hr />
<h3><a id="2%E9%97%AD%E5%8C%85%E7%9A%84%E6%84%8F%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>2. 闭包的意义</strong></h3>
<h4><a id="1%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(1) 数据封装</strong></h4>
<ul>
<li>
<p>闭包可以用于创建私有变量和方法，从而实现数据封装。</p>
</li>
<li>
<p>私有变量只能在闭包内部访问，外部无法直接修改或访问。</p>
</li>
</ul>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">function createCounter() {
  let count = 0; // 私有变量

  return {
    increment() {
      count++;
    },
    getCount() {
      return count;
    }
  };
}

const counter = createCounter();
counter.increment();
console.log(counter.getCount()); // 输出: 1
</code></pre>
<ul>
<li>在上面的例子中，<code>count</code> 是一个私有变量，只能通过 <code>increment</code> 和 <code>getCount</code> 方法访问和修改。</li>
</ul>
<hr />
<h4><a id="2%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(2) 回调函数</strong></h4>
<ul>
<li>闭包常用于回调函数中，确保回调函数可以访问定义时的上下文。</li>
</ul>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">function fetchData(callback) {
  setTimeout(() =&gt; {
    const data = &quot;Some data&quot;;
    callback(data);
  }, 1000);
}

function processData() {
  const prefix = &quot;Processed: &quot;;

  fetchData(function (data) {
    console.log(prefix + data); // 访问外部函数的变量
  });
}

processData(); // 输出: Processed: Some data

</code></pre>
<ul>
<li>在上面的例子中，回调函数可以访问 <code>processData</code> 函数中的 <code>prefix</code> 变量。</li>
</ul>
<hr />
<h4><a id="3%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(3) 函数柯里化</strong></h4>
<ul>
<li>闭包可以用于实现函数柯里化（Currying），即将一个多参数函数转换为一系列单参数函数。</li>
</ul>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">function add(a) {
  return function (b) {
    return a + b;
  };
}

const add5 = add(5); // 返回一个函数，a 被固定为 5
console.log(add5(10)); // 输出: 15

</code></pre>
<ul>
<li>在上面的例子中，<code>add5</code> 是一个闭包，它记住了 <code>a</code> 的值（5）。</li>
</ul>
<hr />
<h4><a id="4%E6%A8%A1%E5%9D%97%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(4) 模块模式</strong></h4>
<ul>
<li>闭包可以用于实现模块模式，将相关的变量和函数封装在一个作用域中，避免污染全局作用域。</li>
</ul>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">const module = (function () {
  const privateVar = &quot;I am private&quot;;

  function privateMethod() {
    console.log(privateVar);
  }

  return {
    publicMethod() {
      privateMethod();
    }
  };
})();

module.publicMethod(); // 输出: I am private
</code></pre>
<ul>
<li>在上面的例子中，<code>privateVar</code> 和 <code>privateMethod</code> 是私有的，只能通过 <code>publicMethod</code> 访问。</li>
</ul>
<hr />
<h3><a id="3%E9%97%AD%E5%8C%85%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>3. 闭包的注意事项</strong></h3>
<h4><a id="1%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(1) 内存泄漏</strong></h4>
<ul>
<li>
<p>闭包会导致外部函数的变量无法被垃圾回收，从而可能导致内存泄漏。</p>
</li>
<li>
<p>如果不再需要闭包，应该手动解除引用。</p>
</li>
</ul>
<h5><a id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例：</h5>
<pre><code class="language-javascript">function createHeavyClosure() {
  const largeArray = new Array(1000000).fill(&quot;data&quot;);

  return function () {
    console.log(largeArray[0]);
  };
}

let heavyFunc = createHeavyClosure();
heavyFunc(); // 使用闭包

// 不再需要时，解除引用
heavyFunc = null;

</code></pre>
<hr />
<h4><a id="2%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>(2) 性能问题</strong></h4>
<ul>
<li>
<p>闭包会增加作用域链的长度，从而可能影响性能。</p>
</li>
<li>
<p>在性能敏感的场景中，应谨慎使用闭包。</p>
</li>
</ul>

            </div>


            <div style="margin-top: 50px;">

                <!-- giscus 评论 -->
                <script src="https://giscus.app/client.js"
                        data-repo="layliu/giscus-comment"
                        data-repo-id="R_kgDOJtN4ng"
                        data-category="Announcements"
                        data-category-id="DIC_kwDOJtN4ns4CXE-q"
                        data-mapping="pathname"
                        data-strict="0"
                        data-reactions-enabled="1"
                        data-emit-metadata="0"
                        data-input-position="top"
                        data-theme="light"
                        data-lang="zh-CN"
                        crossorigin="anonymous"
                        async>
                </script>


            </div>


        </article>
    </div>
</div>

<script src="asset/jquery-3.3.1.min.js"></script>

<!-- 增加zoom效果 -->
<script src="asset/zoom.js"></script>
<!-- <script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script> -->
<script>
    $(function () {
        $('img').each(function () {
            $(this).attr("data-action", 'zoom');
        });
    });
</script>





<script>
    $(document).ready(function () {
        $('#footer').show()
    })


</script>
  <!-- <footer id="footer" class="cuckoo page-footer" style="display: none">
    <div class="wrapper">
        <p>Designed and Written by <a href="mailto:justbb@gmail.com">liulei</a></p>
    </div>
</footer> -->
<!-- 
 -->
